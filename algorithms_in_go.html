<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="A Beginner’s Guide to Learning Algorithms with Golang" />
  <title>Introduction to Algorithms with Golang</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="output/tex/styles.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Introduction to Algorithms with Golang</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#chapter-1-introduction-to-golang"
id="toc-chapter-1-introduction-to-golang">Chapter 1: Introduction to
Golang</a>
<ul>
<li><a href="#control-structures" id="toc-control-structures">Control
Structures</a></li>
<li><a href="#functions" id="toc-functions">Functions</a></li>
<li><a href="#error-handling" id="toc-error-handling">Error
Handling</a></li>
<li><a href="#debugging" id="toc-debugging">Debugging</a></li>
<li><a href="#exercises" id="toc-exercises">Exercises</a></li>
</ul></li>
<li><a
href="#chapter-2-complexity-analysis-and-introduction-to-algorithms"
id="toc-chapter-2-complexity-analysis-and-introduction-to-algorithms">Chapter
2: Complexity Analysis and Introduction to Algorithms</a>
<ul>
<li><a href="#exercises-1" id="toc-exercises-1">Exercises</a></li>
</ul></li>
<li><a href="#chapter-3-sorting-algorithms"
id="toc-chapter-3-sorting-algorithms">Chapter 3: Sorting Algorithms</a>
<ul>
<li><a href="#bubble-sort" id="toc-bubble-sort">Bubble Sort</a></li>
<li><a href="#selection-sort" id="toc-selection-sort">Selection
Sort</a></li>
<li><a href="#insertion-sort" id="toc-insertion-sort">Insertion
Sort</a></li>
<li><a href="#quick-sort" id="toc-quick-sort">Quick Sort</a></li>
<li><a href="#merge-sort" id="toc-merge-sort">Merge Sort</a></li>
<li><a href="#heap-sort" id="toc-heap-sort">Heap Sort</a></li>
<li><a href="#exercises-2" id="toc-exercises-2">Exercises</a></li>
</ul></li>
<li><a href="#chapter-4-searching-algorithms"
id="toc-chapter-4-searching-algorithms">Chapter 4: Searching
Algorithms</a>
<ul>
<li><a href="#linear-search" id="toc-linear-search">Linear
Search</a></li>
<li><a href="#binary-search" id="toc-binary-search">Binary
Search</a></li>
<li><a href="#interpolation-search"
id="toc-interpolation-search">Interpolation Search</a></li>
<li><a href="#exponential-search"
id="toc-exponential-search">Exponential Search</a></li>
<li><a href="#exercises-3" id="toc-exercises-3">Exercises</a></li>
</ul></li>
<li><a href="#chapter-5-recursion-and-backtracking"
id="toc-chapter-5-recursion-and-backtracking">Chapter 5: Recursion and
Backtracking</a>
<ul>
<li><a href="#implementations-of-recursion-in-golang"
id="toc-implementations-of-recursion-in-golang">Implementations of
recursion in Golang</a></li>
<li><a href="#backtracking" id="toc-backtracking">Backtracking</a></li>
</ul></li>
<li><a href="#chapter-6-algorithmic-techniques"
id="toc-chapter-6-algorithmic-techniques">Chapter 6: Algorithmic
Techniques</a>
<ul>
<li><a href="#divide-and-conquer" id="toc-divide-and-conquer">Divide and
conquer</a></li>
<li><a href="#dynamic-programming" id="toc-dynamic-programming">Dynamic
Programming</a></li>
<li><a href="#greedy-algorithms" id="toc-greedy-algorithms">Greedy
algorithms</a>
<ul>
<li><a href="#exercises-4" id="toc-exercises-4">Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-7-graph-algorithms"
id="toc-chapter-7-graph-algorithms">Chapter 7: Graph Algorithms</a>
<ul>
<li><a href="#exercises-5" id="toc-exercises-5">Exercises</a></li>
</ul></li>
<li><a href="#chapter-8-greedy-algorithms"
id="toc-chapter-8-greedy-algorithms">Chapter 8: Greedy
Algorithms</a></li>
<li><a href="#chapter-9-divide-and-conquer-algorithms"
id="toc-chapter-9-divide-and-conquer-algorithms">Chapter 9: Divide and
Conquer Algorithms</a>
<ul>
<li><a href="#exercises-6" id="toc-exercises-6">Exercises</a></li>
</ul></li>
<li><a href="#chapter-10-string-algorithms"
id="toc-chapter-10-string-algorithms">Chapter 10: String Algorithms</a>
<ul>
<li><a href="#exercises-7" id="toc-exercises-7">Exercises</a></li>
</ul></li>
<li><a href="#chapter-11-tree-algorithms"
id="toc-chapter-11-tree-algorithms">Chapter 11: Tree Algorithms</a>
<ul>
<li><a href="#exercises-8" id="toc-exercises-8">Exercises</a></li>
</ul></li>
<li><a href="#chapter-12-hashing-algorithms"
id="toc-chapter-12-hashing-algorithms">Chapter 12: Hashing
Algorithms</a>
<ul>
<li><a href="#exercises-9" id="toc-exercises-9">Exercises</a></li>
</ul></li>
<li><a href="#chapter-13-advanced-topics"
id="toc-chapter-13-advanced-topics">Chapter 13: Advanced Topics</a></li>
<li><a href="#appendix-solutions-to-exercises"
id="toc-appendix-solutions-to-exercises">Appendix: Solutions to
Exercises</a>
<ul>
<li><a href="#chapter-1-solutions" id="toc-chapter-1-solutions">Chapter
1 Solutions</a></li>
<li><a href="#chapter-3-solutions" id="toc-chapter-3-solutions">Chapter
3 Solutions</a></li>
<li><a href="#chapter-4-excerise" id="toc-chapter-4-excerise">Chapter 4
Excerise</a></li>
<li><a href="#chapter-5-recursion-and-backtracking-1"
id="toc-chapter-5-recursion-and-backtracking-1">Chapter 5: Recursion and
Backtracking</a></li>
<li><a href="#chapter-6-algorithmic-techniques-1"
id="toc-chapter-6-algorithmic-techniques-1">Chapter 6: Algorithmic
Techniques</a></li>
<li><a href="#chapter-7-graph-algorithms-1"
id="toc-chapter-7-graph-algorithms-1">Chapter 7: Graph
Algorithms</a></li>
<li><a href="#chapter-8-greedy-algorithms-1"
id="toc-chapter-8-greedy-algorithms-1">Chapter 8: Greedy
Algorithms</a></li>
<li><a href="#chapter-9-divide-and-conquer-algorithms-1"
id="toc-chapter-9-divide-and-conquer-algorithms-1">Chapter 9: Divide and
Conquer Algorithms</a></li>
<li><a href="#chapter-10-string-algorithms-1"
id="toc-chapter-10-string-algorithms-1">Chapter 10: String
Algorithms</a></li>
<li><a href="#chapter-11-tree-algorithms-1"
id="toc-chapter-11-tree-algorithms-1">Chapter 11: Tree
Algorithms</a></li>
<li><a href="#chapter-12-hashing-algorithms-1"
id="toc-chapter-12-hashing-algorithms-1">Chapter 12: Hashing
Algorithms</a></li>
<li><a href="#chapter-13-advanced-topics-1"
id="toc-chapter-13-advanced-topics-1">Chapter 13 Advanced
Topics</a></li>
</ul></li>
</ul>
</nav>
<h1 id="chapter-1-introduction-to-golang">Chapter 1: Introduction to
Golang</h1>
<p>Golang, also known as Go, is an open-source programming language
developed by Google. It was first introduced in 2007 and has since
gained popularity for its simplicity, concurrency, and efficiency.
Golang is designed to be easy to learn, read, and write, with a concise
syntax and a strong emphasis on modularity and code reuse. It is
particularly well-suited for building large-scale, distributed systems
and web applications. Golang also features a garbage collector, built-in
concurrency support, and a rich standard library that includes packages
for network programming, cryptography, and more.</p>
<p>To install and set up the Go environment, follow these steps:</p>
<ol type="1">
<li>Download the latest version of Go from the official website at <a
href="https://golang.org/dl/" class="uri">https://golang.org/dl/</a>.
Choose the appropriate installer for your operating system.</li>
<li>Once the installer has finished downloading, run it and follow the
installation instructions.</li>
<li>After the installation is complete, open a new terminal window or
command prompt.</li>
<li>Verify that Go is installed correctly by typing
<code>go version</code> in the terminal. You should see the version
number of the installed Go compiler.</li>
<li>Set the GOPATH environment variable to specify the directory where
your Go code will be stored. For example, you could set it to
<code>~/ on Unix-based systems or</code>%USERPROFILE% on Windows. You
can set this variable in your system’s environment variables or in your
shell’s configuration file.</li>
<li>Create a new directory to store your Go code. You can name it
whatever you like.</li>
<li>Start coding in Go! You can use any text editor or integrated
development environment (IDE) to write your code. When you’re ready to
compile and run your code, use the <code>go run</code> command followed
by the name of your Go source file.</li>
</ol>
<p>That’s it! You’re now ready to start building applications in Go.</p>
<p>In Go, the basic syntax includes the following:</p>
<ul>
<li>The semicolon (;) is optional at the end of a line</li>
<li>Curly braces ({}) are used to define blocks of code</li>
<li>Comments can be added using <code>//</code> for single-line comments
or <code>/* */</code> for multi-line comments</li>
</ul>
<p>Go has the following built-in data types:</p>
<ul>
<li>Numeric types: <code>int</code>, <code>int8</code>,
<code>int16</code>, <code>int32</code>, <code>int64</code>,
<code>uint</code>, <code>uint8</code>, <code>uint16</code>,
<code>uint32</code>, <code>uint64</code>, <code>float32</code>,
<code>float64</code>, <code>complex64</code>,
<code>complex128</code></li>
<li>Boolean type: <code>bool</code></li>
<li>String type: <code>string</code></li>
<li>Error type: <code>error</code></li>
<li>Pointer types: <code>*T</code></li>
<li>Composite types: arrays, slices, maps, and structures</li>
</ul>
<p>Here is an example program that demonstrates some of the basic syntax
and data types in Go:</p>
<pre class="golang"><code>package main

import &quot;fmt&quot;

func main() {
 // declare and initialize variables
 var i int = 42
 var f float64 = 3.14159
 var b bool = true
 var s string = &quot;Hello, world!&quot;

 // print out the values of the variables
 fmt.Println(i)
 fmt.Println(f)
 fmt.Println(b)
 fmt.Println(s)

 // perform arithmetic operations
 sum := i + 10
 diff := f - 1.0
 product := i * 2
 quotient := f / 2.0

 // print out the results of the operations
 fmt.Println(sum)
 fmt.Println(diff)
 fmt.Println(product)
 fmt.Println(quotient)
}</code></pre>
<p>This program declares and initializes variables of different data
types, prints out their values, and performs arithmetic operations on
them. The <code>fmt</code> package is used to output text to the
console.</p>
<p>Control structures and functions are important concepts in Go that
allow you to control the flow of your program and define reusable blocks
of code. Here’s a brief overview of these concepts:</p>
<h3 id="control-structures">Control Structures</h3>
<p>Go has several control structures that you can use to control the
flow of your program:</p>
<ul>
<li><code>if</code> statements: Used to conditionally execute code based
on a boolean expression.</li>
<li><code>for</code> loops: Used to iterate over a range of values or to
loop until a certain condition is met.</li>
<li><code>switch</code> statements: Used to conditionally execute code
based on the value of a variable.</li>
<li><code>break</code> and <code>continue</code> statements: Used to
exit a loop or skip an iteration.</li>
</ul>
<p>Here’s an example program that demonstrates some of these control
structures:</p>
<pre class="golang"><code>package main

import &quot;fmt&quot;

func main() {
 // if statement
 x := 10
 if x &gt; 5 {
    fmt.Println(&quot;x is greater than 5&quot;)
 }

 // for loop
 for i := 0; i &lt; 5; i++ {
    fmt.Println(i)
 }

 // switch statement
 y := 2
 switch y {
    case 1:
        fmt.Println(&quot;y is 1&quot;)
    case 2:
        fmt.Println(&quot;y is 2&quot;)
    default:
    fmt.Println(&quot;y is not 1 or 2&quot;)
 }

 // break and continue statements
 for i := 0; i &lt; 10; i++ {
    if i == 5 {
        break
    }
    if i%2 == 0 {
        continue
    }
    fmt.Println(i)
 }
}</code></pre>
<h3 id="functions">Functions</h3>
<p>Functions are blocks of code that can be called and reused throughout
your program. In Go, functions are declared using the <code>func</code>
keyword, followed by the function name, parameter list (if any), return
type (if any), and body. Here’s an example program that defines and
calls a simple function:</p>
<pre class="golang"><code>package main

import &quot;fmt&quot;

// function that returns the sum of two integers
func add(a, b int) int {
 return a + b
}

func main() {
 // call the add function
 sum := add(3, 5)
 fmt.Println(sum)
}</code></pre>
<p>In this program, the <code>add</code> function takes two integers as
parameters and returns their sum. The <code>main</code> function calls
the <code>add</code> function with arguments 3 and 5, and then prints
out the result.</p>
<p>Functions can also return multiple values, be passed as arguments to
other functions, and even be defined anonymously using function
literals.</p>
<p>Functions are an important part of Go programming language. They are
blocks of code that perform a specific task and can be called from other
parts of the program. Functions can also return values to the calling
code.</p>
<p>In Go, functions are defined using the <code>func</code> keyword,
followed by the function name, a list of parameters enclosed in
parentheses, and the function body enclosed in curly braces. Here’s an
example of a simple function in Go:</p>
<pre class="golang"><code>func add(a, b int) int {
 return a + b
}</code></pre>
<p>In this example, the <code>add</code> function takes two integer
arguments and returns their sum as an integer.</p>
<p>Go functions can also return multiple values. Here’s an example of a
function that returns both a string and an integer:</p>
<pre class="golang"><code>func getInfo(name string, age int) (string, int) {
 return name, age
}</code></pre>
<p>In this example, the <code>getInfo</code> function takes a string and
an integer as arguments, and returns both of them as a tuple.</p>
<p>Go also has the concept of variadic functions, which can accept an
arbitrary number of arguments. Here’s an example of a variadic function
that calculates the sum of an arbitrary number of integers:</p>
<pre class="golang"><code>func sum(nums ...int) int {
 result := 0
 for _, num := range nums {
    result += num
 }
 return result
}</code></pre>
<p>In this example, the <code>sum</code> function takes any number of
integer arguments and adds them together.</p>
<p>Functions can also be assigned to variables and passed around as
arguments to other functions. This allows for the creation of
higher-order functions, which are functions that take other functions as
arguments or return functions as results. Here’s an example of a
higher-order function that takes a function as an argument:</p>
<pre class="golang"><code>func apply(f func(int) int, x int) int {
 return f(x)
}

func double(x int) int {
 return 2 * x
}

func main() {
 result := apply(double, 5)
 fmt.Println(result) // prints &quot;10&quot;
}</code></pre>
<p>In this example, the <code>apply</code> function takes a function
<code>f</code> and an integer <code>x</code> as arguments, and applies
<code>f</code> to <code>x</code>. The <code>double</code> function is
defined separately and is passed as an argument to <code>apply</code>.
The <code>main</code> function then calls <code>apply</code> with
<code>double</code> and the value <code>5</code>, and prints out the
result.</p>
<p>In summary, functions are a powerful tool in Go that allow for
modular, reusable code. They can be used to perform specific tasks,
return values, and even be passed as arguments to other functions.</p>
<p>In Go, a pointer is a variable that holds the memory address of
another variable. Pointers are used to indirectly refer to a variable
and to share data between different parts of a program.</p>
<p>To declare a pointer variable in Go, we use the <code>*</code>
operator followed by the data type of the variable being pointed to. For
example, to declare a pointer to an integer variable, we can use the
following code:</p>
<pre class="golang"><code>var ptr *int</code></pre>
<p>Here, <code>ptr</code> is a pointer to an integer variable. To
initialize <code>ptr</code> to point to an integer variable, we can use
the address-of operator <code>&amp;</code> followed by the variable
name:</p>
<pre class="golang"><code>var num int = 10
ptr = &amp;num</code></pre>
<p>Now <code>ptr</code> points to the memory location where the integer
variable <code>num</code> is stored.</p>
<p>To access the value of the variable being pointed to by a pointer, we
use the <code>*</code> operator followed by the pointer variable name.
For example, to access the value of the integer variable pointed to by
<code>ptr</code>, we can use the following code:</p>
<pre class="golang"><code>var val int = *ptr</code></pre>
<p>Here, <code>val</code> is assigned the value of the integer variable
pointed to by <code>ptr</code>.</p>
<p>Pointers can also be passed as arguments to functions, allowing the
function to modify the value of the original variable being pointed to.
Here’s an example of a function that takes a pointer to an integer
variable and increments its value:</p>
<pre class="golang"><code>func increment(ptr \*int) {
 *ptr = *ptr + 1
}

func main() {
 var num int = 10
 increment(&amp;num)
 fmt.Println(num) // prints &quot;11&quot;
}</code></pre>
<p>In this example, <code>increment</code> takes a pointer to an integer
variable <code>ptr</code>, and increments its value using the
<code>*</code> operator. The <code>main</code> function declares an
integer variable <code>num</code>, calls <code>increment</code> with the
address of <code>num</code> using the <code>&amp;</code> operator, and
prints the updated value of <code>num</code>.</p>
<p>In summary, pointers are an important feature in Go that allow us to
indirectly refer to variables and share data between different parts of
a program. They are used to pass variables by reference, allowing
functions to modify the original value of a variable.</p>
<p>In Go, a package is a collection of related Go source files that can
be used to build software. Go comes with a large standard library of
packages, but you can also create your own packages and import them into
your code.</p>
<p>To create a new package, you simply need to create a directory with
the same name as your package, and add one or more <code>.go</code>
files containing your package’s source code. For example, let’s say we
want to create a package called <code>math</code> that provides some
basic mathematical functions. We can create a new directory called
<code>math</code> and add a file called `math. with the following
code:</p>
<pre class="golang"><code>package math

func Add(x, y int) int {
 return x + y
}

func Sub(x, y int) int {
 return x - y
}</code></pre>
<p>This package provides two functions, <code>Add</code> and
<code>Sub</code>, which perform addition and subtraction on integers.
Notice that the first line of the file declares the package name with
the <code>package</code> keyword.</p>
<p>To use this package in another Go program, we simply need to import
it with the <code>import</code> keyword, like so:</p>
<pre class="golang"><code>import &quot;path/to/math&quot;

func main() {
 x := 10
 y := 5
 sum := math.Add(x, y)
 diff := math.Sub(x, y)
 fmt.Printf(&quot;Sum: %d, Difference: %d\n&quot;, sum, diff)
}</code></pre>
<p>Here, we import the <code>math</code> package using its import path,
which is the relative path to the directory containing the package from
the Go source file that’s importing it. We then call the
<code>Add</code> and <code>Sub</code> functions from the
<code>math</code> package to perform some basic arithmetic.</p>
<p>It’s important to note that when importing a package, Go executes the
package’s <code>init</code> function, if it exists, before any other
code in the importing file. The <code>init</code> function is a special
function that can be used to perform package-level initialization, such
as registering database drivers or initializing global state.</p>
<p>In summary, packages are a fundamental building block in Go that
allow you to organize your code into logical units and share it between
different projects. Go’s standard library provides many useful packages,
but you can also create your own packages and import them into your code
as needed.</p>
<p>Handling errors and debugging are important skills for any
programmer, and Go provides several tools and techniques to help with
these tasks.</p>
<h2 id="error-handling">Error Handling</h2>
<p>In Go, errors are represented as values of the <code>error</code>
interface. Functions that may produce an error typically return both a
result value and an error value. The caller is responsible for checking
the error value and taking appropriate action if an error occurred.
Here’s an example:</p>
<pre class="golang"><code>func doSomething() (string, error) {
 // ...
 if err != nil {
 return &quot;&quot;, err
 }
 return result, nil
}

func main() {
 result, err := doSomething()
 if err != nil {
    log.Fatalf(&quot;Error: %s&quot;, err)
 }
 fmt.Println(result)
}</code></pre>
<p>In this example, the <code>doSomething</code> function returns a
result value and an error value. The caller checks the error value and
logs an error message if an error occurred.</p>
<p>Go also provides the <code>panic</code> and <code>recover</code>
functions for handling more severe errors. <code>panic</code> is used to
indicate that something unexpected has happened and the program cannot
continue, while <code>recover</code> is used to catch a
<code>panic</code> and allow the program to gracefully exit. However,
these functions should be used sparingly and only in exceptional
circumstances.</p>
<h2 id="debugging">Debugging</h2>
<p>Go provides several built-in tools for debugging, including the
<code>fmt</code> package for printing values and the <code>log</code>
package for logging messages. Go also includes the
<code>go tool trace</code> command, which allows you to trace the
execution of your program and analyze its performance.</p>
<p>In addition to these built-in tools, there are several third-party
debugging tools available for Go, such as the <code>delve</code>
debugger and the <code>pprof</code> performance profiling tool.</p>
<p>Debugging in Go typically involves using a combination of these tools
to identify and fix issues in your code. Some best practices for
debugging in Go include:</p>
<ul>
<li>Write tests: Writing tests for your code can help you identify and
isolate issues more easily.</li>
<li>Use logging: Adding logging statements to your code can help you
track down issues and understand the flow of your program.</li>
<li>Use a debugger: When all else fails, a debugger can be a powerful
tool for stepping through your code and identifying issues.</li>
</ul>
<p>By following these best practices and leveraging the built-in and
third-party tools available, you can become an effective Go developer
and quickly identify and fix issues in your code.</p>
<p>Here are some basic practice exercises in Go:</p>
<h2 id="exercises">Exercises</h2>
<ol type="1">
<li>Write a program that prints the numbers from 1 to 100, but for
multiples of three, print “Fizz” instead of the number, and for
multiples of five, print “Buzz”. For numbers that are multiples of both
three and five, print “FizzBuzz”.</li>
<li>Write a program that takes a string as input and prints out the
number of vowels in the string.</li>
<li>Write a program that reads in a list of integers from the user and
prints out the sum of the integers.</li>
<li>Write a program that reads in a list of strings from the user and
prints out the longest string.</li>
<li>Write a program that takes a number as input and prints out whether
the number is even or odd.</li>
<li>Write a program that reads in a list of integers from the user and
prints out the largest and smallest integers in the list.</li>
<li>Write a program that reads in a list of integers from the user and
prints out only the even integers in the list.</li>
<li>Write a program that takes a list of strings as input and prints out
the strings in reverse order.</li>
<li>Write a program that reads in a list of integers from the user and
prints out the median of the integers.</li>
<li>Write a program that takes a string as input and prints out the
string with all the vowels removed.</li>
</ol>
<p>These exercises cover a range of basic programming concepts in Go,
such as loops, conditionals, functions, and input/output.</p>
<h1
id="chapter-2-complexity-analysis-and-introduction-to-algorithms">Chapter
2: Complexity Analysis and Introduction to Algorithms</h1>
<p>In computer science, an algorithm is a set of instructions or rules
that describe how to perform a particular task or solve a specific
problem. Algorithms are used to process data, manipulate objects, and
perform other tasks in software development and other fields that
involve computing.</p>
<p>An algorithm is typically described in a step-by-step manner, with
each step representing a specific operation or instruction that needs to
be executed to solve the problem. Algorithms can be expressed in many
different ways, including natural language, flowcharts, pseudocode, and
programming languages.</p>
<p>Algorithms are essential in computer science because they provide a
systematic way to approach complex problems and enable efficient
computation. They are used in a wide range of applications, such as data
processing, artificial intelligence, cryptography, and optimization.</p>
<p>Some common algorithm design techniques include:</p>
<ul>
<li>Brute force: This involves trying every possible solution to a
problem until the correct one is found.</li>
<li>Divide and conquer: This involves breaking a problem down into
smaller sub-problems that can be solved independently and then combining
the solutions to solve the larger problem.</li>
<li>Dynamic programming: This involves breaking a problem down into
smaller sub-problems and solving each sub-problem only once, storing the
solutions in memory for future use.</li>
<li>Greedy algorithms: This involves making the locally optimal choice
at each step of the algorithm, with the hope that the overall solution
will be optimal.</li>
</ul>
<p>Effective algorithm design requires a deep understanding of
problem-solving techniques, data structures, and algorithms.</p>
<p>Algorithm design and analysis are two important aspects of computer
science and software engineering. Algorithm design is the process of
creating an efficient and effective algorithm to solve a given problem,
while algorithm analysis involves evaluating the performance of an
algorithm in terms of time and space complexity.</p>
<p>The process of algorithm design typically involves the following
steps:</p>
<ol type="1">
<li>Problem statement: Clearly define the problem that needs to be
solved.</li>
<li>Input/output specification: Define the inputs and outputs of the
algorithm.</li>
<li>Algorithm specification: Define the steps of the algorithm in a
clear and concise manner.</li>
<li>Algorithm optimization: Optimize the algorithm to make it as
efficient and effective as possible.</li>
<li>Algorithm verification: Test the algorithm using test cases and
verify that it produces the expected results.</li>
</ol>
<p>Algorithm analysis involves evaluating the performance of an
algorithm in terms of time and space complexity. The time complexity of
an algorithm is the amount of time it takes to execute as a function of
the size of the input data. The space complexity of an algorithm is the
amount of memory it requires to execute as a function of the size of the
input data.</p>
<p>There are different techniques for analyzing the time and space
complexity of algorithms, including:</p>
<ol type="1">
<li>Big O notation: This is a mathematical notation that describes the
upper bound of an algorithm’s time or space complexity.</li>
<li>Asymptotic analysis: This involves analyzing the behavior of an
algorithm as the input size approaches infinity.</li>
<li>Worst-case analysis: This involves analyzing the performance of an
algorithm for the worst-case input data.</li>
<li>Average-case analysis: This involves analyzing the performance of an
algorithm for the average-case input data.</li>
</ol>
<p>Effective algorithm design and analysis are critical to creating
software that is efficient, scalable, and robust.</p>
<p>Big-O notation is a mathematical notation used to describe the upper
bound of an algorithm’s time or space complexity. It is used to describe
the worst-case scenario of an algorithm’s performance, i.e., the longest
amount of time it would take to run or the largest amount of memory it
would require.</p>
<p>Big-O notation expresses the growth rate of an algorithm’s time or
space complexity as a function of the input size. For example, an
algorithm with a time complexity of O(n) would take linear time to
execute, while an algorithm with a time complexity of O(n^2) would take
quadratic time to execute.</p>
<p>The significance of Big-O notation lies in its ability to compare the
efficiency of different algorithms in terms of their worst-case
performance. It provides a standardized way of measuring the performance
of algorithms, regardless of the programming language or platform used
to implement them.</p>
<p>By using Big-O notation, developers can evaluate the efficiency of
different algorithms and choose the one that best meets their
performance requirements. They can also optimize existing algorithms to
make them more efficient and effective.</p>
<p>Overall, Big-O notation is an important tool for software developers
and computer scientists to analyze and optimize algorithms, ensuring
that software systems are efficient, scalable, and performant.</p>
<p>Time and space complexity are two important measures used to analyze
the efficiency of algorithms.</p>
<p>Time complexity refers to the amount of time an algorithm takes to
run as a function of the size of the input. It is typically expressed
using Big-O notation, which provides an upper bound on the number of
operations an algorithm performs as the input size increases. For
example, an algorithm with a time complexity of O(n) will take linear
time to run, while an algorithm with a time complexity of O(n^2) will
take quadratic time to run.</p>
<p>Space complexity refers to the amount of memory an algorithm requires
to run as a function of the size of the input. Like time complexity, it
is also typically expressed using Big-O notation, which provides an
upper bound on the amount of memory an algorithm requires as the input
size increases.</p>
<p>Analyzing the time and space complexity of an algorithm is important
because it helps developers evaluate the efficiency of different
algorithms and choose the one that best meets their performance
requirements. It also helps identify potential performance issues and
bottlenecks, allowing developers to optimize their code for better
performance.</p>
<p>In general, developers aim to create algorithms with the lowest
possible time and space complexity to ensure their software systems are
efficient, scalable, and performant.</p>
<p>Worst, best, and average case analysis are three approaches used to
analyze the time and space complexity of algorithms.</p>
<p>Worst-case analysis refers to the analysis of an algorithm’s time or
space complexity when it is given the input that results in the worst
possible performance. For example, for a sorting algorithm, the
worst-case input would be an array in reverse order. The worst-case
analysis gives an upper bound on the time or space complexity of an
algorithm.</p>
<p>Best-case analysis, on the other hand, refers to the analysis of an
algorithm’s time or space complexity when it is given the input that
results in the best possible performance. For example, for a sorting
algorithm, the best-case input would be an already sorted array. The
best-case analysis gives a lower bound on the time or space complexity
of an algorithm.</p>
<p>Average-case analysis refers to the analysis of an algorithm’s time
or space complexity when it is given a random input. This is often the
most realistic scenario for analyzing an algorithm’s performance.
Average-case analysis gives an estimate of the expected time or space
complexity of an algorithm over all possible inputs.</p>
<p>In general, worst-case analysis is the most commonly used approach
because it provides a guarantee on the performance of an algorithm.
However, best-case and average-case analysis can also be useful in
certain contexts, such as when analyzing the performance of algorithms
in real-world scenarios.</p>
<p>Asymptotic notation is a mathematical notation used to describe the
growth rate of a function as its input size approaches infinity. It is
used to express the time and space complexity of algorithms in terms of
their upper bounds or lower bounds, ignoring constant factors and
lower-order terms.</p>
<p>The most commonly used asymptotic notations are:</p>
<ol type="1">
<li>Big-O notation (O): This notation represents the upper bound of an
algorithm’s time or space complexity. It describes the worst-case
scenario for the performance of an algorithm.</li>
<li>Omega notation (Ω): This notation represents the lower bound of an
algorithm’s time or space complexity. It describes the best-case
scenario for the performance of an algorithm.</li>
<li>Theta notation (θ): This notation represents both the upper and
lower bounds of an algorithm’s time or space complexity. It describes
the average-case scenario for the performance of an algorithm.</li>
</ol>
<p>Asymptotic notation provides a standardized way of measuring the
performance of algorithms, allowing developers to compare different
algorithms and choose the one that best meets their performance
requirements. It also allows developers to analyze the scalability of
their algorithms, ensuring that they can handle large inputs without
sacrificing performance.</p>
<p>Overall, asymptotic notation is an important tool for software
developers and computer scientists to analyze and optimize algorithms,
ensuring that software systems are efficient, scalable, and
performant.</p>
<p>There are many types of algorithms, each with its own unique
characteristics and applications. Here are some common types of
algorithms:</p>
<ol type="1">
<li>Sorting algorithms: These algorithms arrange a list of items in a
specific order, such as alphabetical or numerical order. Examples of
sorting algorithms include bubble sort, insertion sort, and
quicksort.</li>
<li>Searching algorithms: These algorithms look for a specific item in a
list of items. Examples of searching algorithms include linear search
and binary search.</li>
<li>Pathfinding algorithms: These algorithms find the shortest or
fastest path between two points in a network, such as a road map or a
computer network. Examples of pathfinding algorithms include Dijkstra’s
algorithm and A* search.</li>
<li>Compression algorithms: These algorithms reduce the size of a file
or data set, making it easier to store and transmit. Examples of
compression algorithms include Huffman coding and Lempel-Ziv-Welch (LZW)
encoding.</li>
<li>Encryption algorithms: These algorithms encode data to protect it
from unauthorized access. Examples of encryption algorithms include
Advanced Encryption Standard (AES) and Rivest-Shamir-Adleman (RSA).</li>
<li>Machine learning algorithms: These algorithms use statistical
methods to enable computers to learn from data and improve their
performance over time. Examples of machine learning algorithms include
neural networks and decision trees.</li>
<li>Backtracking algorithms: These algorithms find solutions to problems
by incrementally building and testing potential solutions. Examples of
backtracking algorithms include the eight queens problem and the
traveling salesman problem.</li>
</ol>
<p>These are just a few examples of the many types of algorithms that
exist. The specific type of algorithm used in a particular application
depends on the nature of the problem and the desired outcome.</p>
<p>Here are some practice exercises for basic Big-O notation:</p>
<h2 id="exercises-1">Exercises</h2>
<ol type="1">
<li>Determine the Big-O notation for the following code:</li>
</ol>
<pre class="golang"><code>for i in range(n):
 for j in range(n):
 print(i, j)</code></pre>
<p>Answer: O(n^2)</p>
<p>Explanation: The code has two nested loops that iterate over n
elements each. Therefore, the total number of iterations is n * n =
n^2.</p>
<ol start="2" type="1">
<li>Determine the Big-O notation for the following code:</li>
</ol>
<pre class="golang"><code>for i in range(n):
 for j in range(n):
 for k in range(n):
 print(i, j, k)</code></pre>
<p>Answer: O(n^3)</p>
<p>Explanation: The code has three nested loops that iterate over n
elements each. Therefore, the total number of iterations is n * n * n =
n^3.</p>
<ol start="3" type="1">
<li>Determine the Big-O notation for the following code:</li>
</ol>
<pre class="golang"><code>for i in range(n):
 print(i)</code></pre>
<p>Answer: O(n)</p>
<p>Explanation: The code has a single loop that iterates over n
elements.</p>
<ol start="4" type="1">
<li>Determine the Big-O notation for the following code:</li>
</ol>
<pre class="golang"><code>for i in range(n):
 print(i)

for j in range(n):
 print(j)</code></pre>
<p>Answer: <span class="math inline"><em>O</em>(<em>n</em>)</span></p>
<p>Explanation: The code has two loops, each iterating over n elements.
However, the loops are not nested, so the total number of iterations is
2n, which simplifies to O(n).</p>
<ol start="5" type="1">
<li>Determine the Big-O notation for the following code:</li>
</ol>
<pre class="golang"><code>for i in range(n):
 for j in range(i):
 print(i, j)</code></pre>
<p>Answer: <span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span></p>
<p>Explanation: The outer loop iterates over n elements, and the inner
loop iterates over i elements, where i is less than n. Therefore, the
total number of iterations is roughly 1 + 2 + 3 + … + n, which is
equivalent to the sum of the first n integers, which is n(n+1)/2. This
simplifies to <span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>.</p>
<h1 id="chapter-3-sorting-algorithms">Chapter 3: Sorting Algorithms</h1>
<p>Here are explanations and examples of Bubble Sort, Selection Sort,
and Insertion Sort algorithms in Golang:</p>
<h2 id="bubble-sort">Bubble Sort</h2>
<p>Bubble Sort is a simple sorting algorithm that repeatedly steps
through the list, compares adjacent elements and swaps them if they are
in the wrong order. The pass through the list is repeated until the list
is sorted.</p>
<pre class="golang"><code>func bubbleSort(arr []int) {
    n := len(arr)
        for i := 0; i &lt; n-1; i++ {
            for j := 0; j &lt; n-i-1; j++ {
                if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}</code></pre>
<h2 id="selection-sort">Selection Sort</h2>
<p>Selection Sort is an in-place comparison sorting algorithm that
divides the input list into two parts: the sublist of items already
sorted, which is built up from left to right at the front (left) of the
list, and the sublist of items remaining to be sorted that occupy the
rest of the list. Initially, the sorted sublist is empty and the
unsorted sublist is the entire input list. The algorithm proceeds by
finding the smallest element in the unsorted sublist, exchanging
(swapping) it with the leftmost unsorted element (putting it in sorted
order), and moving the sublist boundaries one element to the right.</p>
<pre class="golang"><code>func selectionSort(arr []int) {
 n := len(arr)
 for i := 0; i &lt; n-1; i++ {
    minIdx := i
    for j := i + 1; j &lt; n; j++ {
        if arr[j] &lt; arr[minIdx] {
            minIdx = j
        }
    }
    arr[i], arr[minIdx] = arr[minIdx], arr[i]
    }
}</code></pre>
<h2 id="insertion-sort">Insertion Sort</h2>
<p>Insertion Sort is a simple sorting algorithm that builds the final
sorted array one item at a time. It is much less efficient on large
lists than more advanced algorithms such as quicksort, heapsort, or
merge sort. However, insertion sort provides several advantages:</p>
<ul>
<li>Simple implementation</li>
<li>Efficient for small data sets</li>
<li>Adaptive, i.e., efficient for data sets that are already
substantially sorted</li>
<li>Stable, i.e., does not change the relative order of elements with
equal keys</li>
</ul>
<pre class="golang"><code>func insertionSort(arr []int) {
    n := len(arr)
    for i := 1; i &lt; n; i++ {
        key := arr[i]
        j := i - 1
        for j &gt;= 0 &amp;&amp; arr[j] &gt; key {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}
</code></pre>
<p>Here are explanations and examples of Quick Sort, Merge Sort, and
Heap Sort algorithms in Golang:</p>
<h2 id="quick-sort">Quick Sort</h2>
<p>Quick Sort is a sorting algorithm that uses the divide-and-conquer
strategy to sort an array or list. It works by selecting a ‘pivot’
element from the array and partitioning the other elements into two
sub-arrays, according to whether they are less than or greater than the
pivot. The sub-arrays are then sorted recursively.</p>
<pre class="golang"><code>func quickSort(arr []int, low, high int) {
    if low &lt; high {
        pivot := partition(arr, low, high)
        quickSort(arr, low, pivot-1)
        quickSort(arr, pivot+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j &lt; high; j++ {
        if arr[j] &lt; pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}</code></pre>
<h2 id="merge-sort">Merge Sort</h2>
<p>Merge Sort is a sorting algorithm that uses the divide-and-conquer
strategy to sort an array or list. It works by dividing the input array
into two halves, sorting each half, and then merging the two sorted
halves back together.</p>
<pre class="golang"><code>func mergeSort(arr []int) []int {
    if len(arr) &lt;= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0)
    i, j := 0, 0
    for i &lt; len(left) &amp;&amp; j &lt; len(right) {
        if left[i] &lt; right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}</code></pre>
<h2 id="heap-sort">Heap Sort</h2>
<p>Heap Sort is a comparison-based sorting algorithm that uses a binary
heap data structure to sort an array or list. It works by first building
a binary heap from the input array and then repeatedly extracting the
minimum (or maximum) element from the heap and inserting it into the
sorted part of the array.</p>
<pre class="golang"><code>func heapSort(arr []int) {
    n := len(arr)
    for i := n/2 - 1; i &gt;= 0; i-- {
        heapify(arr, n, i)
    }
    for i := n - 1; i &gt; 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }
}

func heapify(arr []int, n, i int) {
    largest := i
    l := 2*i + 1
    r := 2*i + 2
    if l &lt; n &amp;&amp; arr[l] &gt; arr[largest] {
        largest = l
    }
    if r &lt; n &amp;&amp; arr[r] &gt; arr[largest] {
        largest = r
    }
    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}</code></pre>
<p>Here’s a brief comparison of the sorting algorithms we’ve discussed
in terms of their time complexity and performance:</p>
<ul>
<li><strong>Bubble Sort, Selection Sort, and Insertion Sort</strong>:
These algorithms are all O(n^2) in the worst case, which means that
their time complexity grows quadratically with the size of the input.
They are relatively simple to implement and can be useful for small
input sizes, but they are not recommended for larger datasets as they
can be slow.</li>
<li><strong>Quick Sort</strong>: Quick Sort is generally considered one
of the fastest sorting algorithms, with an average time complexity of
O(n log n). However, in the worst case (when the pivot element is always
the smallest or largest element), its time complexity can be O(n^2).
Quick Sort is also an in-place sorting algorithm, meaning it doesn’t
require any additional memory to sort the input.</li>
<li><strong>Merge Sort</strong>: Merge Sort has an average and
worst-case time complexity of O(n log n), making it a good choice for
large input sizes. However, it requires O(n) additional memory to sort
the input, which may be a consideration in some applications.</li>
<li><strong>Heap Sort</strong>: Heap Sort has a worst-case time
complexity of O(n log n), making it an efficient algorithm for sorting
large datasets. Like Quick Sort, it is also an in-place sorting
algorithm, so it doesn’t require any additional memory.</li>
</ul>
<p>A stable sorting algorithm is a sorting algorithm that preserves the
relative order of equal elements in the input data set. For example, if
you sort a list of students by their grades using a stable sorting
algorithm, students with the same grade will remain in the same order as
they were before sorting. Some examples of stable sorting algorithms are
bubble sort, insertion sort, merge sort and count sort.</p>
<p>Overall, the choice of sorting algorithm depends on the specific
requirements of your application. If you are dealing with small input
sizes and simplicity of implementation is a priority, Bubble Sort,
Selection Sort, or Insertion Sort may be sufficient. If you are dealing
with larger datasets and speed is a priority, Quick Sort or Heap Sort
may be better choices. If you need to sort large datasets and additional
memory is not a concern, Merge Sort may be a good option.</p>
<h2 id="exercises-2">Exercises</h2>
<p>Here are some practice exercises related to sorting algorithms:</p>
<ol type="1">
<li>Implement a sorting algorithm of your choice in Golang, and test it
with a variety of input sizes to compare its performance. How does its
time complexity match up with the theoretical expectations?</li>
<li>Write a function in Golang that generates an array of n integers
with random values between 0 and 1000. Then, use one or more sorting
algorithms to sort the array in ascending order. Print out the sorted
array and compare its performance with different sorting
algorithms.</li>
<li>Implement a stable sorting algorithm of your choice in Golang, and
compare it with an unstable sorting algorithm (e.g. quicksort). What is
the difference between a stable and unstable sorting algorithm, and when
might you prefer one over the other?</li>
<li>Suppose you are given two arrays A and B, each containing n
integers. Write a function in Golang that returns an array C containing
all the elements from A and B, sorted in ascending order. You may assume
that both A and B are already sorted.</li>
<li>Write a function in Golang that takes an array of n integers as
input, and returns the k-th smallest element in the array. You may
assume that k is between 1 and n, and that the array contains distinct
elements.</li>
</ol>
<h1 id="chapter-4-searching-algorithms">Chapter 4: Searching
Algorithms</h1>
<p>Sure, here are some explanations and code examples for linear search
and binary search in Golang:</p>
<h3 id="linear-search">Linear Search</h3>
<p>Linear search is a simple search algorithm that checks every element
in a list or array, in order, until the desired element is found.</p>
<pre class="golang"><code>func linearSearch(arr []int, target int) int {
 for i, val := range arr {
 if val == target {
 return i
 }
 }
 return -1
}</code></pre>
<p>In this implementation, we use a for loop to iterate over the array,
checking each element to see if it matches the target value. If a match
is found, we return its index; otherwise, we return -1 to indicate that
the target was not found.</p>
<h3 id="binary-search">Binary Search</h3>
<p>Binary search is a more efficient search algorithm that works by
dividing a sorted list in half and checking the middle element. If the
middle element is the target, we return its index. Otherwise, if the
target is less than the middle element, we recursively search the left
half of the list. If the target is greater than the middle element, we
recursively search the right half of the list.</p>
<pre class="golang"><code>func binarySearch(arr []int, target int) int {
 low, high := 0, len(arr)-1
 for low &lt;= high {
 mid := (low + high) / 2
 if arr[mid] == target {
 return mid
 } else if arr[mid] &lt; target {
 low = mid + 1
 } else {
 high = mid - 1
 }
 }
 return -1
}</code></pre>
<p>In this implementation, we use a while loop to repeatedly divide the
list in half until the target is found or the remaining list is empty.
The low and high variables represent the indices of the first and last
elements in the current sublist, respectively. We use the mid index to
check the middle element of the sublist, and compare it to the target to
decide whether to continue searching the left or right half of the
sublist.</p>
<p>Note that for binary search to work correctly, the input array must
be sorted in ascending order.</p>
<p>Sure, here are some explanations and code examples for interpolation
search and exponential search in Golang:</p>
<h3 id="interpolation-search">Interpolation Search</h3>
<p>Interpolation search is a search algorithm that works by estimating
the position of the target element based on its value relative to the
minimum and maximum values in the array. It then uses this estimate to
narrow down the search range and perform a binary search on that
range.</p>
<pre class="golang"><code>func interpolationSearch(arr []int, target int) int {
 low, high := 0, len(arr)-1
 for low &lt;= high &amp;&amp; target &gt;= arr[low] &amp;&amp; target &lt;= arr[high] {
 pos := low + ((target-arr[low])*(high-low))/(arr[high]-arr[low])
 if arr[pos] == target {
 return pos
 } else if arr[pos] &lt; target {
 low = pos + 1
 } else {
 high = pos - 1
 }
 }
 return -1
}</code></pre>
<p>In this implementation, we use a while loop to perform an estimation
of the position of the target element using the formula
<code>pos = low + ((target-arr[low])*(high-low))/(arr[high]-arr[low])</code>.
If the target is found at this position, we return the index of the
element. Otherwise, we check whether the target is in the left or right
half of the remaining array and adjust the low and high indices
accordingly.</p>
<p>Note that interpolation search works best on uniformly distributed
arrays, and may perform poorly on arrays with unevenly spaced
values.</p>
<h3 id="exponential-search">Exponential Search</h3>
<p>Exponential search is a search algorithm that works by doubling the
search range until an element greater than the target is found. It then
performs a binary search on the last search range to locate the
target.</p>
<pre class="golang"><code>func exponentialSearch(arr []int, target int) int {
 if arr[0] == target {
 return 0
 }
 i := 1
 for i &lt; len(arr) &amp;&amp; arr[i] &lt;= target {
 i *= 2
 }
 low, high := i/2, min(i, len(arr)-1)
 for low &lt;= high {
 mid := (low + high) / 2
 if arr[mid] == target {
 return mid
 } else if arr[mid] &lt; target {
 low = mid + 1
 } else {
 high = mid - 1
 }
 }
 return -1
}

func min(a, b int) int {
 if a &lt; b {
 return a
 }
 return b
}</code></pre>
<p>In this implementation, we start with a search range of size 1, and
keep doubling the size of the range until an element greater than the
target is found. We then perform a binary search on the last search
range to locate the target. The <code>min</code> function is used to
prevent the high index from exceeding the length of the array.</p>
<p>Note that exponential search works best on sorted arrays with
unbounded or unknown size, as it can quickly determine an upper bound
for the search range. However, it may perform worse than binary search
on small arrays.</p>
<p>In terms of time complexity, the searching algorithms can be compared
as follows:</p>
<ul>
<li>Linear search has a worst-case time complexity of O(n), where n is
the size of the array.</li>
<li>Binary search has a worst-case time complexity of O(log n), where n
is the size of the array. However, binary search only works on sorted
arrays.</li>
<li>Interpolation search also has a worst-case time complexity of O(log
n), but it works best on uniformly distributed arrays.</li>
<li>Exponential search has a worst-case time complexity of O(log i),
where i is the index of the element greater than the target. However,
exponential search requires that the array is sorted, and may not
perform as well as binary search on small arrays.</li>
</ul>
<p>In terms of performance, the choice of searching algorithm may depend
on the size and distribution of the array, as well as the
characteristics of the target element.</p>
<ul>
<li>Linear search is simple to implement and works well on small,
unsorted arrays. However, it may perform poorly on large arrays.</li>
<li>Binary search is efficient on large, sorted arrays, but requires
that the array is sorted first. It is also more complex to implement
than linear search.</li>
<li>Interpolation search is efficient on uniformly distributed arrays,
and can be faster than binary search in some cases. However, it may
perform poorly on unevenly spaced arrays.</li>
<li>Exponential search is efficient on sorted arrays with unknown or
unbounded size, as it can quickly determine an upper bound for the
search range. However, it may perform worse than binary search on small
arrays, and requires that the array is sorted.</li>
</ul>
<p>Overall, the choice of searching algorithm may depend on the specific
requirements of the application, and should take into account factors
such as the size and distribution of the array, the frequency and nature
of the search queries, and the performance characteristics of the target
hardware.</p>
<p>Here are example implementations of linear search, binary search,
interpolation search, and exponential search in Golang:</p>
<pre class="golang"><code>// Linear search function
func linearSearch(arr []int, target int) int {
 for i, val := range arr {
 if val == target {
 return i
 }
 }
 return -1 // target not found
}

// Binary search function
func binarySearch(arr []int, target int) int {
 low, high := 0, len(arr)-1
 for low &lt;= high {
 mid := (low + high) / 2
 if arr[mid] == target {
 return mid
 } else if arr[mid] &lt; target {
 low = mid + 1
 } else {
 high = mid - 1
 }
 }
 return -1 // target not found
}

// Interpolation search function
func interpolationSearch(arr []int, target int) int {
 low, high := 0, len(arr)-1
 for low &lt;= high &amp;&amp; target &gt;= arr[low] &amp;&amp; target &lt;= arr[high] {
 pos := low + ((target - arr[low]) * (high - low) / (arr[high] - arr[low]))
 if arr[pos] == target {
 return pos
 } else if arr[pos] &lt; target {
 low = pos + 1
 } else {
 high = pos - 1
 }
 }
 return -1 // target not found
}

// Exponential search function
func exponentialSearch(arr []int, target int) int {
 if arr[0] == target {
 return 0
 }
 i := 1
 for i &lt; len(arr) &amp;&amp; arr[i] &lt;= target {
 i *= 2
 }
 return binarySearch(arr[i/2:min(i, len(arr))], target)
}</code></pre>
<p>Note that these implementations assume that the input array is sorted
in ascending order. Also, the return value of each function is the index
of the target element in the array, or -1 if the target is not
found.</p>
<p>Here are some practice exercises on searching algorithms in
Golang:</p>
<h2 id="exercises-3">Exercises</h2>
<ol type="1">
<li>Implement a function <code>linearSearchString</code> that performs
linear search on an array of strings, and returns the index of the
target string, or -1 if the target is not found. The function should
have the signature:</li>
</ol>
<pre class="golang"><code>func linearSearchString(arr []string, target string) int</code></pre>
<ol start="2" type="1">
<li>Implement a function <code>binarySearchFloat64</code> that performs
binary search on an array of float64 values, and returns the index of
the target value, or -1 if the target is not found. The function should
have the signature:</li>
</ol>
<pre class="golang"><code>func binarySearchFloat64(arr []float64, target float64) int</code></pre>
<ol start="3" type="1">
<li>Implement a function <code>interpolationSearchInt</code> that
performs interpolation search on an array of int values, and returns the
index of the target value, or -1 if the target is not found. The
function should have the signature:</li>
</ol>
<pre class="golang"><code>func interpolationSearchInt(arr []int, target int) int</code></pre>
<ol start="4" type="1">
<li>Implement a function <code>exponentialSearchString</code> that
performs exponential search on an array of strings, and returns the
index of the target string, or -1 if the target is not found. The
function should have the signature:</li>
</ol>
<pre class="golang"><code>func exponentialSearchString(arr []string, target string) int</code></pre>
<p>Feel free to modify the input types or return values of these
functions as needed.</p>
<h1 id="chapter-5-recursion-and-backtracking">Chapter 5: Recursion and
Backtracking</h1>
<p>Recursion is a powerful technique in computer programming where a
function calls itself from within its own code. In other words,
recursion is a process in which a function is called inside its own
definition until a certain condition is met.</p>
<p>The main advantage of using recursion is that it can often simplify
the code, and make it more elegant and easier to understand. Recursion
can also be used to solve complex problems that would be difficult to
solve with an iterative approach.</p>
<p>Some common applications of recursion include:</p>
<ol type="1">
<li>Traversing complex data structures such as trees and graphs:
Recursive functions can be used to traverse complex data structures such
as trees and graphs. In fact, many tree and graph algorithms, such as
depth-first search and breadth-first search, are implemented using
recursion.</li>
<li>Sorting algorithms: Some sorting algorithms, such as quicksort and
mergesort, use recursion to divide the input array into smaller
sub-arrays, and then sort the sub-arrays recursively.</li>
<li>Mathematical problems: Recursion can be used to solve various
mathematical problems, such as factorial, Fibonacci sequence, and the
Tower of Hanoi puzzle.</li>
<li>Backtracking algorithms: Many backtracking algorithms, such as the
N-Queens problem and the Knight’s Tour problem, are implemented using
recursion.</li>
</ol>
<p>However, it’s important to note that recursion can have some
drawbacks. Recursive functions can be less efficient than iterative
functions, especially when dealing with large data sets. Additionally,
recursion can sometimes lead to stack overflow errors if the recursive
function is called too many times without returning.</p>
<p>Overall, recursion is a powerful tool in programming, and its
applications are numerous. By understanding the principles of recursion
and its various applications, programmers can write more efficient and
elegant code that solves complex problems.</p>
<h2 id="implementations-of-recursion-in-golang">Implementations of
recursion in Golang</h2>
<p>Here are the implementations of the factorial and Fibonacci sequence
functions using recursion in Golang:</p>
<pre class="golang"><code>// Factorial function using recursion
func factorial(n int) int {
 if n == 0 {
 return 1
 } else {
 return n * factorial(n-1)
 }
}

// Fibonacci sequence function using recursion
func fibonacci(n int) int {
 if n == 0 {
 return 0
 } else if n == 1 {
 return 1
 } else {
 return fibonacci(n-1) + fibonacci(n-2)
 }
}</code></pre>
<p>The <code>factorial</code> function takes an integer <code>n</code>
as input, and returns the factorial of <code>n</code>. The base case of
the recursion is when <code>n</code> is equal to 0, in which case the
function returns 1. Otherwise, the function calls itself with
<code>n-1</code> as the input, and multiplies the result with
<code>n</code>.</p>
<p>The <code>fibonacci</code> function takes an integer <code>n</code>
as input, and returns the <code>n</code>th number in the Fibonacci
sequence. The base case of the recursion is when <code>n</code> is equal
to 0 or 1, in which case the function returns 0 or 1 respectively.
Otherwise, the function calls itself with <code>n-1</code> and
<code>n-2</code> as inputs, and adds the results.</p>
<p>It’s important to note that both of these functions have an
exponential time complexity of O(2^n), meaning that they can become very
slow for large input values. However, they demonstrate the power of
recursion and how it can be used to solve mathematical problems.</p>
<p>Recursion is often used in sorting and searching algorithms to divide
the problem into smaller sub-problems, and then solve each sub-problem
recursively. Here are some examples of sorting and searching algorithms
that use recursion:</p>
<ol type="1">
<li>Quicksort: Quicksort is a sorting algorithm that uses recursion to
sort an array. It works by choosing a pivot element, and then
partitioning the array into two sub-arrays based on the pivot. It then
recursively sorts the sub-arrays using quicksort.</li>
<li>Mergesort: Mergesort is a sorting algorithm that uses recursion to
sort an array. It works by dividing the array into two sub-arrays, and
then recursively sorting each sub-array using mergesort. It then merges
the two sorted sub-arrays into a single sorted array.</li>
<li>Binary search: Binary search is a searching algorithm that uses
recursion to find the index of a target element in a sorted array. It
works by comparing the target element with the middle element of the
array. If the middle element is equal to the target, the function
returns the index of the middle element. If the middle element is
greater than the target, the function recursively searches the left half
of the array. If the middle element is less than the target, the
function recursively searches the right half of the array.</li>
<li>Depth-first search (DFS): DFS is a searching algorithm that uses
recursion to traverse a graph or tree. It works by starting at a root
node, and then recursively visiting all of its neighbors. It then visits
the neighbors of each visited node, until all nodes have been
visited.</li>
</ol>
<p>By using recursion in these algorithms, it’s possible to write more
elegant and concise code that solves complex problems. However, it’s
important to be aware of the potential drawbacks of recursion, such as
stack overflow errors and poor performance for large data sets.</p>
<h2 id="backtracking">Backtracking</h2>
<p>Backtracking is an algorithmic technique that is used to solve
problems by systematically searching for a solution among all possible
options. It works by incrementally building a solution to the problem,
and then “backtracking” when it determines that the solution cannot be
completed.</p>
<p>The basic idea behind backtracking is to explore all possible
solutions by trying out each possible candidate solution, one at a time.
If a candidate solution is found to be invalid (i.e. it does not satisfy
the problem constraints), the algorithm “backs up” and tries a different
candidate solution. This process continues until either a valid solution
is found, or all possible solutions have been explored.</p>
<p>Backtracking can be applied to a wide range of problems,
including:</p>
<ol type="1">
<li>Sudoku: In the game of Sudoku, the player is presented with a
partially filled grid of numbers, and must fill in the remaining cells
so that each row, column, and sub-grid contains all of the numbers from
1 to 9 without repeating. Backtracking can be used to solve Sudoku
puzzles by systematically testing each candidate number for each cell,
and backtracking when an invalid solution is encountered.</li>
<li>N-Queens: The N-Queens problem involves placing N chess queens on an
N x N chessboard in such a way that no two queens can attack each other.
Backtracking can be used to solve the N-Queens problem by systematically
placing each queen on the board, and backtracking when an invalid
solution is encountered.</li>
<li>Subset Sum: The Subset Sum problem involves finding a subset of
numbers from a given set of numbers that add up to a target sum.
Backtracking can be used to solve the Subset Sum problem by
systematically testing each possible combination of numbers, and
backtracking when the sum exceeds the target.</li>
</ol>
<p>By using backtracking, it’s possible to solve complex problems that
may not be solvable using other algorithmic techniques. However,
backtracking algorithms can be computationally expensive, and may not be
efficient for large data sets.</p>
<p>Here are some practice exercises for backtracking: ## Exercises 1.
Write a function to solve the Sudoku puzzle using backtracking.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Solve Sudoku puzzle</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    board <span class="op">:=</span> <span class="op">[][]</span><span class="dt">int</span><span class="op">{</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">5</span><span class="op">},</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">4</span><span class="op">},</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> solveSudoku<span class="op">(</span>board<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Sudoku solution:&quot;</span><span class="op">)</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>        printBoard<span class="op">(</span>board<span class="op">)</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;No solution exists.&quot;</span><span class="op">)</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="2" type="1">
<li>Write a function to solve the N-Queens problem using
backtracking.</li>
<li>Write a function to solve the Subset Sum problem using
backtracking.</li>
<li>Write a function to find all possible permutations of a given set of
numbers using backtracking.</li>
<li>Write a function to find all possible combinations of a given set of
numbers that add up to a target sum using backtracking.</li>
</ol>
<p>These exercises will help you develop your backtracking skills and
improve your problem-solving abilities. Good luck!</p>
<h1 id="chapter-6-algorithmic-techniques">Chapter 6: Algorithmic
Techniques</h1>
<h2 id="divide-and-conquer">Divide and conquer</h2>
<p>Divide and conquer is a powerful algorithmic technique that involves
breaking down a complex problem into smaller sub-problems, solving each
sub-problem recursively, and then combining the solutions of the
sub-problems to form the final solution to the original problem. The
basic steps involved in the divide and conquer technique are:</p>
<ol type="1">
<li>Divide the problem into smaller sub-problems.</li>
<li>Solve each sub-problem recursively.</li>
<li>Combine the solutions of the sub-problems to form the final solution
to the original problem.</li>
</ol>
<p>Divide and conquer algorithms are often used in problems that can be
broken down into smaller, similar sub-problems. Some common examples of
problems that can be solved using the divide and conquer technique
include:</p>
<ol type="1">
<li>Merge Sort: The merge sort algorithm involves breaking down an
unsorted list into smaller sub-lists, sorting each sub-list recursively,
and then merging the sorted sub-lists back together to form the final
sorted list.</li>
<li>Binary Search: The binary search algorithm involves dividing a
sorted list into two halves, searching the left or right half depending
on the value being searched for, and repeating the process until the
target value is found.</li>
<li>Quick Sort: The quick sort algorithm involves selecting a pivot
element from an unsorted list, partitioning the list into smaller
sub-lists based on the pivot element, and then recursively sorting the
sub-lists.</li>
</ol>
<p>Divide and conquer algorithms are often more efficient than other
types of algorithms for large datasets, since they can exploit
parallelism and reduce the amount of data that needs to be processed at
any given time. However, they can be more complex to implement and may
require more memory than other types of algorithms.</p>
<h2 id="dynamic-programming">Dynamic Programming</h2>
<p>Dynamic programming is an algorithmic technique used to solve complex
problems by breaking them down into smaller sub-problems and solving
each sub-problem only once. The technique is particularly useful for
problems that exhibit optimal substructure and overlapping
sub-problems.</p>
<p>The basic steps involved in dynamic programming are:</p>
<ol type="1">
<li>Divide the problem into smaller sub-problems</li>
<li>Identify the overlapping sub-problems</li>
<li>Store the results of each sub-problem in a table</li>
<li>Use the stored results to solve each sub-problem only once</li>
<li>Combine the solutions of the sub-problems to form the final solution
to the original problem</li>
</ol>
<p>Dynamic programming is often used for optimization problems, such as
finding the shortest path between two points or maximizing profit in a
business. Some common examples of problems that can be solved using
dynamic programming include:</p>
<ol type="1">
<li>Knapsack Problem: Given a set of items, each with a weight and a
value, determine the items to include in a collection so that the total
weight is less than or equal to a given limit and the total value is as
large as possible.</li>
<li>Fibonacci Sequence: The Fibonacci sequence is a sequence of numbers
in which each number is the sum of the two preceding ones. Dynamic
programming can be used to efficiently calculate the Nth number in the
sequence.</li>
<li>Longest Common Subsequence: Given two sequences, find the length of
the longest subsequence present in both of them.</li>
</ol>
<p>Dynamic programming is particularly useful when the problem has many
overlapping sub-problems, as it allows for these sub-problems to be
solved only once, rather than repeatedly solving the same sub-problem
multiple times. This results in a significant improvement in efficiency
and performance.</p>
<h2 id="greedy-algorithms">Greedy algorithms</h2>
<p>Greedy algorithms are a class of algorithms that make the locally
optimal choice at each step with the hope of finding a global optimum.
They work by selecting the best available option at each step, without
considering the overall consequences of that choice.</p>
<p>The basic steps involved in a greedy algorithm are:</p>
<ol type="1">
<li>Define the problem and the set of possible solutions.</li>
<li>Choose the best available option for the current step.</li>
<li>Update the problem and the set of possible solutions based on the
chosen option.</li>
<li>Repeat steps 2 and 3 until the problem is solved.</li>
</ol>
<p>Some common examples of problems that can be solved using greedy
algorithms include:</p>
<ol type="1">
<li>Minimum Spanning Tree: Given a weighted graph, find the spanning
tree that has the minimum weight.</li>
<li>Huffman Coding: Given a set of characters and their frequencies,
find the binary code that represents each character while minimizing the
total number of bits required.</li>
<li>Interval Scheduling: Given a set of tasks with start and end times,
find the maximum number of non-overlapping tasks that can be
scheduled.</li>
</ol>
<p>Greedy algorithms are often used when the problem has a property
called “the greedy choice property,” which means that the locally
optimal choice at each step will lead to a globally optimal solution.
However, they may not always provide the optimal solution for all
problems and can be inefficient in some cases.</p>
<p>Backtracking is an algorithmic technique used to solve problems by
exploring all possible solutions, but eliminating those that do not
satisfy the problem constraints or requirements. It is an iterative
approach that tries different solutions to a problem until a
satisfactory solution is found.</p>
<p>The basic steps involved in a backtracking algorithm are:</p>
<ol type="1">
<li>Define the problem and the set of possible solutions.</li>
<li>Choose a possible solution and move to the next step.</li>
<li>Check if the solution satisfies the problem constraints or
requirements.</li>
<li>If the solution satisfies the constraints, then move to the next
step. Otherwise, backtrack and try a different solution.</li>
<li>Repeat steps 2-4 until a satisfactory solution is found.</li>
</ol>
<p>Some common examples of problems that can be solved using
backtracking include:</p>
<ol type="1">
<li>N-Queens Problem: Given an n x n chessboard, place n queens on the
board such that no two queens threaten each other.</li>
<li>Sudoku Solver: Given a partially filled 9 x 9 Sudoku grid, fill in
the remaining cells such that each row, column, and 3 x 3 sub-grid
contains all the digits from 1 to 9.</li>
<li>Knight’s Tour: Given a chessboard and a knight, find a sequence of
moves such that the knight visits every square on the board exactly
once.</li>
</ol>
<p>Backtracking can be a very effective technique for solving problems
that require the exploration of all possible solutions. However, it can
be time-consuming and inefficient for problems with a large solution
space, as it involves trying every possible solution until a
satisfactory one is found.</p>
<p>Branch and Bound is an algorithmic technique used to solve
optimization problems. It works by exploring the space of all possible
solutions using a divide-and-conquer approach. It uses a tree-like data
structure to represent the solution space, where each node represents a
partial solution and each edge represents a possible next step.</p>
<p>The basic steps involved in a branch and bound algorithm are:</p>
<ol type="1">
<li>Define the problem and the set of possible solutions.</li>
<li>Divide the solution space into smaller subspaces, or branches, that
can be explored independently.</li>
<li>Assign a lower bound to each branch, representing the minimum
possible value that can be achieved by any solution in that branch.</li>
<li>Explore each branch in a depth-first or breadth-first manner,
selecting the most promising branch based on the lower bound.</li>
<li>Whenever a complete solution is found, update the current best
solution if it is better than the previous best solution.</li>
<li>Prune any branches that cannot possibly contain a better solution
than the current best solution.</li>
<li>Repeat steps 4-6 until all branches have been explored.</li>
</ol>
<p>Some common examples of problems that can be solved using branch and
bound include:</p>
<ol type="1">
<li>Traveling Salesman Problem: Given a set of cities and the distances
between them, find the shortest possible route that visits each city
exactly once and returns to the starting city.</li>
<li>Knapsack Problem: Given a set of items with their weights and
values, and a knapsack with a maximum weight capacity, find the subset
of items that maximizes the total value while fitting within the
knapsack’s capacity.</li>
<li>Graph Coloring Problem: Given a graph, color each vertex such that
no two adjacent vertices have the same color, using the minimum number
of colors possible.</li>
</ol>
<p>Branch and Bound is a powerful technique that can often find optimal
solutions to optimization problems. However, it can be computationally
expensive, especially for problems with a large solution space, and the
choice of lower bound can significantly affect the efficiency and
effectiveness of the algorithm.</p>
<p>Here are some practice exercises for branch and bound:</p>
<h3 id="exercises-4">Exercises</h3>
<ol type="1">
<li>Implement a branch and bound algorithm to solve the knapsack
problem, where each item has a weight and a value, and the goal is to
maximize the total value of items that can fit in a knapsack with a
given weight capacity.</li>
<li>Use a branch and bound algorithm to solve the traveling salesman
problem for a given set of cities and distances between them, where the
goal is to find the shortest possible route that visits each city
exactly once and returns to the starting city.</li>
<li>Implement a branch and bound algorithm to solve the graph coloring
problem for a given graph, where the goal is to color each vertex such
that no two adjacent vertices have the same color, using the minimum
number of colors possible.</li>
<li>Use a branch and bound algorithm to solve the subset sum problem,
where given a set of integers and a target sum, the goal is to find a
subset of integers that add up to the target sum.</li>
<li>Implement a branch and bound algorithm to solve the vehicle routing
problem, where a fleet of vehicles must visit a set of locations to
deliver goods, with each location having a demand and a time window in
which it can be visited. The goal is to find the optimal route for each
vehicle that satisfies the demand and time window constraints.</li>
</ol>
<h1 id="chapter-7-graph-algorithms">Chapter 7: Graph Algorithms</h1>
<p>A graph is a mathematical structure that represents a set of objects,
called vertices or nodes, and the connections between them, called edges
or arcs. Graphs can be used to model a wide variety of real-world
phenomena, such as social networks, transportation networks, and
computer networks.</p>
<p>There are two main ways to represent a graph: the adjacency matrix
and the adjacency list.</p>
<p>An adjacency matrix is a two-dimensional array where the rows and
columns represent the vertices, and the entries represent the edges. If
there is an edge from vertex i to vertex j, then the entry at position
(i, j) in the matrix will be 1, otherwise it will be 0. In a directed
graph, the matrix may not be symmetric.</p>
<p>An adjacency list is a collection of lists, where each list
corresponds to a vertex and contains the vertices that are adjacent to
it. For example, the list for vertex i would contain all the vertices
that have an edge from i to them.</p>
<p>There are also different types of graphs, such as directed and
undirected graphs, weighted and unweighted graphs, and connected and
disconnected graphs.</p>
<p>In a directed graph, the edges have a direction, meaning that the
edge from vertex i to vertex j is different from the edge from vertex j
to vertex i. In an undirected graph, the edges have no direction,
meaning that the edge between vertex i and vertex j is the same as the
edge between vertex j and vertex i.</p>
<p>In a weighted graph, each edge has a weight or cost associated with
it, which can represent the distance, time, or any other metric
associated with the edge. In an unweighted graph, all edges have the
same weight or cost.</p>
<p>In a connected graph, there is a path between any two vertices, while
in a disconnected graph, there are one or more vertices that are not
connected to the rest of the graph.</p>
<p>Understanding the different types of graphs and their representations
is crucial in designing and implementing graph algorithms.</p>
<p>Breadth-first search (BFS) and depth-first search (DFS) are two of
the most commonly used graph traversal algorithms. Both algorithms visit
all the vertices and edges of a graph, but they do so in different
orders.</p>
<p>BFS starts at a given vertex and visits all the vertices that are
reachable from it, in order of their distance from the starting vertex.
It uses a queue to keep track of the vertices to be visited next. BFS is
useful for finding the shortest path between two vertices in an
unweighted graph.</p>
<p>Here is the basic algorithm for BFS:</p>
<ol type="1">
<li>Enqueue the starting vertex onto a queue.</li>
<li>While the queue is not empty, dequeue a vertex and visit it.</li>
<li>Enqueue all its adjacent vertices that have not been visited
yet.</li>
<li>Mark the visited vertex as “visited” to avoid revisiting it.</li>
</ol>
<p>DFS, on the other hand, starts at a given vertex and explores as far
as possible along each branch before backtracking. It uses a stack to
keep track of the vertices to be visited next. DFS is useful for finding
all the connected components of a graph and for solving problems that
require exploring all possible paths through a graph.</p>
<p>Here is the basic algorithm for DFS:</p>
<ol type="1">
<li>Push the starting vertex onto a stack.</li>
<li>While the stack is not empty, pop a vertex and visit it.</li>
<li>Push all its adjacent vertices that have not been visited yet onto
the stack.</li>
<li>Mark the visited vertex as “visited” to avoid revisiting it.</li>
</ol>
<p>Both BFS and DFS have a time complexity of O(V + E), where V is the
number of vertices and E is the number of edges in the graph. However,
BFS uses more memory than DFS since it needs to keep track of all the
vertices in the queue.</p>
<p>Understanding the differences between BFS and DFS is important in
choosing the appropriate algorithm for a given problem.</p>
<p>Dijkstra’s algorithm and Bellman-Ford algorithm are two of the most
widely used shortest path algorithms in graph theory.</p>
<p>Dijkstra’s algorithm is a greedy algorithm that finds the shortest
path from a starting vertex to all other vertices in a weighted graph
with non-negative edge weights. The algorithm uses a priority queue to
keep track of the vertices to be visited next. It starts at the starting
vertex and repeatedly selects the vertex with the lowest distance from
the starting vertex, updates its neighbors’ distances if a shorter path
is found, and adds them to the queue. The algorithm terminates when all
vertices have been visited or the queue is empty.</p>
<p>Here is the basic algorithm for Dijkstra’s algorithm:</p>
<ol type="1">
<li>Assign a distance of 0 to the starting vertex and infinity to all
other vertices.</li>
<li>Add the starting vertex to a priority queue, with its distance as
the priority.</li>
<li>While the priority queue is not empty, dequeue a vertex and visit
it.</li>
<li>For each of its neighbors, calculate the distance to that neighbor
through the current vertex.</li>
<li>If the calculated distance is less than the current distance of the
neighbor, update its distance and add it to the priority queue with its
new distance as the priority.</li>
</ol>
<p>Dijkstra’s algorithm has a time complexity of O((V+E)logV), where V
is the number of vertices and E is the number of edges in the graph.</p>
<p>Bellman-Ford algorithm is another algorithm that finds the shortest
path from a starting vertex to all other vertices in a weighted graph.
It works by relaxing all edges V - 1 times, where V is the number of
vertices in the graph. The algorithm initially assigns infinity to all
vertices except the starting vertex, which is assigned a distance of 0.
In each iteration, the algorithm checks if it can reduce the distance to
any of its neighbors by considering a path that goes through the current
vertex. If a shorter path is found, the algorithm updates the distance
of the neighbor.</p>
<p>Here is the basic algorithm for Bellman-Ford algorithm:</p>
<ol type="1">
<li>Assign a distance of 0 to the starting vertex and infinity to all
other vertices.</li>
<li>Relax all edges V - 1 times.</li>
<li>For each vertex u and its neighbor v, check if the distance to v can
be reduced by going through u.</li>
<li>If a shorter path is found, update the distance of v.</li>
</ol>
<p>Bellman-Ford algorithm has a time complexity of O(VE), where V is the
number of vertices and E is the number of edges in the graph. It can
handle graphs with negative weight edges, but it will not work if the
graph contains a negative weight cycle.</p>
<p>Both algorithms have their strengths and weaknesses, and the choice
of algorithm depends on the specific problem requirements and graph
properties.</p>
<p>Here are some practice exercises for Dijkstra’s algorithm and
Bellman-Ford algorithm:</p>
<h2 id="exercises-5">Exercises</h2>
<ol type="1">
<li>Implement Dijkstra’s algorithm and Bellman-Ford algorithm in
Golang.</li>
<li>Use Dijkstra’s algorithm to find the shortest path from vertex 1 to
all other vertices in the following graph:</li>
</ol>
<pre><code> 4 1
 1-----2-----3
 | | |
 5 2 6
 | | |
 4-----5-----6
 2 3</code></pre>
<p>Assume that the edges are weighted as shown in the diagram.</p>
<ol start="3" type="1">
<li>Use Bellman-Ford algorithm to find the shortest path from vertex A
to all other vertices in the following graph:</li>
</ol>
<pre class="golang"><code> 2
 A----------B
 | \ |
 | \ |
 4| \ |6
 | \ |
 C----------D
 3</code></pre>
<p>Assume that the edges are weighted as shown in the diagram.</p>
<ol start="4" type="1">
<li>Compare the time complexity and performance of Dijkstra’s algorithm
and Bellman-Ford algorithm on a large graph with 1000 vertices and 5000
edges. Which algorithm is faster? Why?</li>
<li>Modify Dijkstra’s algorithm to find the shortest path from a
starting vertex to a target vertex. Stop the algorithm when the target
vertex is visited and return the shortest path.</li>
<li>Modify Bellman-Ford algorithm to detect negative weight cycles in a
graph. Return true if the graph contains a negative weight cycle, false
otherwise.</li>
<li>Use Dijkstra’s algorithm to find the shortest path from vertex 1 to
vertex 6 in the following graph:</li>
</ol>
<pre><code> 1 5
 1-----2-----3
 | | |
 5 2 6
 | | |
 4-----5-----6
 2 1</code></pre>
<p>Assume that the edges are weighted as shown in the diagram.</p>
<ol start="8" type="1">
<li>Use Bellman-Ford algorithm to find the shortest path from vertex A
to vertex D in the following graph:</li>
</ol>
<pre><code> A----------B
 | \ |
 | \ |
 4| \ |6
 | \ |
 C----------D
 3</code></pre>
<p>Assume that the edges are weighted as shown in the diagram.</p>
<p>These exercises will help you understand and practice Dijkstra’s
algorithm and Bellman-Ford algorithm. Good luck!</p>
<h1 id="chapter-8-greedy-algorithms">Chapter 8: Greedy Algorithms</h1>
<p>Greedy algorithms are algorithms that make locally optimal choices at
each step in the hope of finding a global optimum. Here are some
examples of greedy algorithms and their applications:</p>
<ol type="1">
<li>Dijkstra’s algorithm: This is a greedy algorithm for finding the
shortest path between two vertices in a graph. At each step, the
algorithm chooses the vertex with the smallest distance from the
starting vertex and updates the distances of its neighbors. This
algorithm is commonly used in network routing and transportation
planning.</li>
<li>Huffman coding: This is a greedy algorithm for lossless data
compression. It constructs a binary tree of characters based on their
frequency in the input data, and assigns shorter codes to more frequent
characters. This algorithm is widely used in image and audio
compression.</li>
<li>Kruskal’s algorithm: This is a greedy algorithm for finding the
minimum spanning tree of a weighted graph. At each step, the algorithm
chooses the edge with the smallest weight that does not create a cycle,
until all vertices are connected. This algorithm is used in network
design and clustering.</li>
<li>Fractional Knapsack problem: This is a problem where given a set of
items with weights and values, we need to choose a subset of items with
maximum value, subject to a weight constraint. The greedy algorithm for
this problem selects items with the highest value-to-weight ratio until
the weight constraint is reached. This algorithm is used in resource
allocation and portfolio optimization.</li>
<li>Activity selection problem: This is a problem where given a set of
activities with start and finish times, we need to select a maximum
number of non-overlapping activities. The greedy algorithm for this
problem selects the activity with the earliest finish time and removes
all activities that overlap with it, until no more non-overlapping
activities can be selected. This algorithm is used in scheduling and
resource allocation.</li>
</ol>
<p>Greedy algorithms are simple and efficient, but they do not always
guarantee the optimal solution. Therefore, it is important to carefully
choose the problem and analyze the algorithm to ensure that it is
appropriate for the problem and produces satisfactory results.</p>
<p>Sure, here are some examples of greedy algorithms and their
solutions:</p>
<ol type="1">
<li>Fractional Knapsack problem: Given a set of items with weights and
values, we need to choose a subset of items with maximum value, subject
to a weight constraint. The greedy algorithm for this problem selects
items with the highest value-to-weight ratio until the weight constraint
is reached. For example, if we have three items with weights and values
as follows:</li>
</ol>
<p>Item 1: weight=10, value=60 Item 2: weight=20, value=100 Item 3:
weight=30, value=120</p>
<p>and a weight constraint of 50, the algorithm would select item 1 and
item 2, with a total value of 160.</p>
<ol start="2" type="1">
<li>Dijkstra’s algorithm: Given a weighted graph, we need to find the
shortest path between two vertices. The algorithm starts at the source
vertex and visits its neighbors, updating their distances and recording
the shortest path. It then selects the unvisited vertex with the
smallest distance and repeats the process until the destination vertex
is reached. For example, if we have the following graph:</li>
</ol>
<pre><code>    A --4-- B --2-- C
    | |
    ```
    1| 3|
    | |
    D --5-- E --1-- F</code></pre>
<p>and we want to find the shortest path from A to F, the algorithm
would visit the vertices in the following order: A, B, C, E, F, and the
shortest path would be A -&gt; B -&gt; C -&gt; E -&gt; F, with a total
distance of 7.</p>
<ol start="3" type="1">
<li>Kruskal’s algorithm: Given a weighted graph, we need to find the
minimum spanning tree, which is a tree that connects all vertices with
the minimum total weight. The algorithm starts with a forest of
single-vertex trees and repeatedly selects the edge with the smallest
weight that connects two different trees, until all vertices are
connected. For example, if we have the following graph:</li>
</ol>
<pre><code>    A --1-- B --3-- C
    | |
    4| 2|
    | |
    D --5-- E --6-- F</code></pre>
<p>the algorithm would select the edges in the following order: A-B,
B-C, B-E, D-A, E-F, with a total weight of 17.</p>
<p>Greedy algorithms are often used in optimization problems, where we
need to find the best solution from a set of choices. However, it’s
important to note that greedy algorithms don’t always produce the
optimal solution, and there may be other algorithms that provide better
results.</p>
<p>Greedy algorithms are a type of optimization algorithm that make
locally optimal choices at each step in the hope of finding a global
optimum. In contrast, other optimization algorithms like dynamic
programming and divide-and-conquer, consider all possible solutions and
choose the best one based on some criteria.</p>
<p>Compared to dynamic programming, which is a more general technique,
greedy algorithms are often faster and simpler to implement. However,
greedy algorithms are not guaranteed to find the global optimum, and can
sometimes get stuck in a local optimum.</p>
<p>In comparison to divide-and-conquer algorithms, which typically solve
problems by breaking them down into smaller subproblems and solving them
recursively, greedy algorithms don’t divide the problem into smaller
subproblems. Instead, they make decisions that seem optimal at the time,
hoping that these decisions will lead to a globally optimal
solution.</p>
<p>In general, the choice of algorithm depends on the problem being
solved and the constraints involved. Greedy algorithms are often used
when the problem has the property of optimal substructure, which means
that an optimal solution can be constructed from optimal solutions of
its subproblems. However, for problems that don’t have this property,
other algorithms may be more appropriate.</p>
<ol type="1">
<li>Given an array of coins, each with a different value, find the
minimum number of coins required to make a given sum. Assume that there
is an unlimited supply of coins of each denomination. Implement a greedy
algorithm to solve this problem.</li>
<li>You are given n jobs, each with a start time, end time, and profit.
You can only work on one job at a time, and you must finish a job before
starting another. Implement a greedy algorithm to find the maximum
profit that can be obtained from these jobs.</li>
<li>Given a set of intervals, find the maximum number of non-overlapping
intervals that can be selected. Implement a greedy algorithm to solve
this problem.</li>
<li>Given a weighted graph, find the minimum spanning tree (MST) using
Kruskal’s algorithm. Implement the algorithm in Go.</li>
<li>You are given a set of tasks, each with a start time and a deadline.
You can only work on one task at a time, and you must finish a task
before its deadline. Implement a greedy algorithm to find the maximum
number of tasks that can be completed.</li>
<li>Given a set of points on a plane, find the minimum distance between
any two points. Implement a greedy algorithm to solve this problem.</li>
<li>You are given a string of characters. Implement a greedy algorithm
to find the lexicographically smallest permutation of the string.</li>
<li>You are given a set of weighted items and a knapsack with a maximum
capacity. Implement a greedy algorithm to find the maximum value that
can be obtained by selecting a subset of items that fit into the
knapsack.</li>
<li>You are given a set of intervals representing time slots for a
conference. Implement a greedy algorithm to find the maximum number of
talks that can be scheduled without overlapping.</li>
<li>You are given a set of cities and the distances between them.
Implement a greedy algorithm to find the shortest possible tour that
visits each city exactly once.</li>
</ol>
<h1 id="chapter-9-divide-and-conquer-algorithms">Chapter 9: Divide and
Conquer Algorithms</h1>
<p>The divide and conquer technique is a problem-solving paradigm in
computer science and mathematics that involves breaking a problem down
into smaller sub-problems, solving the sub-problems recursively, and
then combining the solutions to the sub-problems to form a solution to
the original problem. The divide and conquer technique is based on the
principle of breaking a problem down into smaller, more manageable
pieces that can be solved independently.</p>
<p>The divide and conquer technique is particularly useful in solving
problems that can be broken down into smaller sub-problems that are
similar to the original problem. This technique is widely used in
algorithms that involve sorting, searching, and merging data, as well as
in other computational problems such as matrix multiplication and graph
traversal.</p>
<p>The divide and conquer technique typically involves three steps:</p>
<ol type="1">
<li>Divide: Break the problem down into smaller sub-problems that can be
solved independently.</li>
<li>Conquer: Solve each of the sub-problems recursively.</li>
<li>Combine: Combine the solutions to the sub-problems to form a
solution to the original problem.</li>
</ol>
<p>By using this technique, complex problems can be broken down into
smaller, more manageable sub-problems, which can be solved more
efficiently than the original problem. The divide and conquer technique
is widely used in computer science and engineering because it provides a
powerful and efficient way to solve complex problems.</p>
<p>Here are some examples of divide and conquer algorithms and their
solutions:</p>
<ol type="1">
<li>Merge Sort: Merge sort is a sorting algorithm that uses the divide
and conquer technique to sort an array of elements. The algorithm works
by dividing the array into two halves, sorting each half recursively,
and then merging the sorted halves to form a sorted array. The time
complexity of merge sort is O(n log n), where n is the number of
elements in the array.</li>
<li>Quick Sort: Quick sort is another sorting algorithm that uses the
divide and conquer technique. The algorithm works by selecting a pivot
element from the array, partitioning the array into two sub-arrays based
on the pivot element, sorting each sub-array recursively, and then
combining the sorted sub-arrays to form a sorted array. The time
complexity of quick sort is O(n log n) on average, but can be O(n^2) in
the worst case.</li>
<li>Binary Search: Binary search is a searching algorithm that uses the
divide and conquer technique to find a specific element in a sorted
array. The algorithm works by repeatedly dividing the array in half and
searching the half that contains the element being searched for. The
time complexity of binary search is O(log n), where n is the number of
elements in the array.</li>
<li>Strassen’s Algorithm: Strassen’s algorithm is an algorithm for
matrix multiplication that uses the divide and conquer technique. The
algorithm works by dividing the input matrices into sub-matrices,
computing the products of the sub-matrices recursively, and then
combining the products to form the product of the original matrices. The
time complexity of Strassen’s algorithm is <span
class="math inline"><em>O</em>(<em>n</em><sup><em>l</em></sup><em>o</em><em>g</em>2(7))</span>,
which is faster than the traditional matrix multiplication
algorithm.</li>
</ol>
<p>These are just a few examples of divide and conquer algorithms and
their solutions. The divide and conquer technique is widely used in
computer science and engineering, and there are many other algorithms
that use this technique to solve various problems.</p>
<p>Divide and conquer is a powerful problem-solving technique that is
used in many algorithms in computer science and engineering. One of the
key advantages of divide and conquer is that it can often be used to
solve problems that are difficult to solve using other techniques. Here
are some comparisons between divide and conquer and other
techniques:</p>
<ol type="1">
<li>Divide and Conquer vs. Brute Force: Brute force algorithms involve
checking all possible solutions to a problem, and are often slow and
inefficient. Divide and conquer, on the other hand, breaks the problem
down into smaller sub-problems, making it more efficient than brute
force algorithms.</li>
<li>Divide and Conquer vs. Dynamic Programming: Dynamic programming is
another problem-solving technique that involves breaking down a problem
into smaller sub-problems. However, dynamic programming uses a bottom-up
approach to solve the sub-problems and build up the solution, whereas
divide and conquer uses a top-down approach. In general, divide and
conquer is more efficient for problems that can be solved recursively,
while dynamic programming is better for problems that have overlapping
sub-problems.</li>
<li>Divide and Conquer vs. Greedy Algorithms: Greedy algorithms are
another problem-solving technique that involves making locally optimal
choices to build up a global solution. Divide and conquer, on the other
hand, breaks the problem down into smaller sub-problems and solves them
recursively. In general, greedy algorithms are faster and simpler than
divide and conquer, but they may not always produce the optimal
solution.</li>
<li>Divide and Conquer vs. Backtracking: Backtracking is another
problem-solving technique that involves exploring all possible solutions
to a problem. Divide and conquer, on the other hand, breaks the problem
down into smaller sub-problems and solves them recursively. In general,
divide and conquer is more efficient than backtracking, but backtracking
is more flexible and can handle a wider range of problems.</li>
</ol>
<p>Overall, the choice of problem-solving technique depends on the
specific problem being solved and the requirements of the solution.
Divide and conquer is a powerful and widely used technique that is
particularly effective for problems that can be solved recursively.</p>
<p>here are some practice exercises on divide and conquer:</p>
<h2 id="exercises-6">Exercises</h2>
<ol type="1">
<li>Implement a divide and conquer algorithm to find the maximum element
in an array.</li>
<li>Implement a divide and conquer algorithm to count the number of
inversions in an array. An inversion is a pair of elements in the array
where the larger element appears before the smaller element.</li>
<li>Implement a divide and conquer algorithm to find the median of two
sorted arrays. The median is the middle element in the combined sorted
array.</li>
<li>Implement a divide and conquer algorithm to find the kth largest
element in an unsorted array.</li>
<li>Implement a divide and conquer algorithm to find the closest pair of
points in a set of 2D points.</li>
<li>Implement a divide and conquer algorithm to solve the maximum
subarray problem. The maximum subarray problem is the task of finding
the contiguous subarray within a one-dimensional array, a[1…n], of
numbers which has the largest sum.</li>
<li>Implement a divide and conquer algorithm to find the closest pair of
points in a set of 3D points.</li>
<li>Implement a divide and conquer algorithm to find the minimum element
in a rotated sorted array.</li>
<li>Implement a divide and conquer algorithm to find the maximum sum of
a subsequence of a given sequence.</li>
<li>Implement a divide and conquer algorithm to find the convex hull of
a set of points in the plane.</li>
</ol>
<p>These exercises will help you practice and reinforce your
understanding of divide and conquer algorithms.</p>
<h1 id="chapter-10-string-algorithms">Chapter 10: String Algorithms</h1>
<p>String algorithms are a class of algorithms that operate on strings
or sequences of characters. They are commonly used in text processing,
bioinformatics, and natural language processing, among other fields.
Some of the applications of string algorithms include:</p>
<ol type="1">
<li>Pattern matching: Pattern matching involves searching for a given
pattern within a larger string. Applications include searching for a
word in a document, finding a gene in a DNA sequence, or searching for a
substring in a string.</li>
<li>String compression: String compression involves encoding a string in
a more compact representation. This can be useful in situations where
storage space is limited, such as in data storage or transmission.</li>
<li>Text editing: Text editing involves manipulating strings, such as
inserting or deleting characters, or replacing substrings with other
strings.</li>
<li>Data encryption: Encryption algorithms use strings to encode and
decode data for secure transmission.</li>
<li>Information retrieval: Information retrieval algorithms use strings
to index and search large datasets, such as search engines or
databases.</li>
<li>Natural language processing: String algorithms are used to analyze
and manipulate natural language data, such as parsing sentences or
identifying parts of speech.</li>
</ol>
<p>These are just a few examples of the applications of string
algorithms, and there are many more depending on the specific field or
problem domain.</p>
<p>String searching algorithms are used to search for a given pattern
within a larger string. The Knuth-Morris-Pratt (KMP) algorithm and the
Boyer-Moore (BM) algorithm are two commonly used string searching
algorithms.</p>
<p>The KMP algorithm is based on the observation that when a mismatch
occurs between the pattern and the text, we can use the information we
already have about the pattern to avoid comparing the same characters
again. Specifically, the algorithm precomputes a table of values that
indicates how far we can shift the pattern to the right in the event of
a mismatch, without missing any possible matches.</p>
<p>The BM algorithm, on the other hand, takes a different approach. It
compares the pattern to the text from right to left, rather than from
left to right as in the KMP algorithm. The algorithm also uses two
tables, the bad character table and the good suffix table, to determine
how far the pattern can be shifted in the event of a mismatch.</p>
<p>Both algorithms have a worst-case time complexity of O(n + m), where
n is the length of the text and m is the length of the pattern. However,
in practice, the BM algorithm tends to be faster than the KMP algorithm
for most cases.</p>
<p>The KMP algorithm is preferred when the pattern is relatively small
and the text is very large. It is also useful when the pattern contains
many repeated characters. On the other hand, the BM algorithm is
preferred when the pattern is relatively large and the text is
relatively small. It is also useful when the pattern contains few
repeated characters.</p>
<p>Overall, both algorithms have their own strengths and weaknesses, and
the choice of which algorithm to use depends on the specific problem at
hand.</p>
<p>String matching algorithms are used to find all occurrences of a
given pattern within a larger string. The Rabin-Karp algorithm and the
suffix tree algorithm are two commonly used string matching
algorithms.</p>
<p>The Rabin-Karp algorithm works by computing a hash function for each
substring of the text that is the same length as the pattern. The hash
function is designed so that two substrings that are the same will have
the same hash value. The algorithm then compares the hash value of each
substring with the hash value of the pattern. If the hash values match,
the algorithm checks to see if the substrings are actually the same. If
they are, the algorithm has found a match.</p>
<p>The suffix tree algorithm works by constructing a tree data structure
that represents all of the suffixes of the text. Each node in the tree
corresponds to a substring of the text, and the edges between nodes
correspond to individual characters. The algorithm then searches the
tree for occurrences of the pattern by following a path through the tree
that matches the pattern.</p>
<p>Both algorithms have a worst-case time complexity of O(n + m), where
n is the length of the text and m is the length of the pattern. However,
in practice, the Rabin-Karp algorithm tends to be slower than the suffix
tree algorithm for most cases.</p>
<p>The Rabin-Karp algorithm is preferred when the pattern is relatively
small and the text is very large. It is also useful when there are
multiple patterns to search for, as the algorithm can check the hash
values of multiple patterns at the same time. On the other hand, the
suffix tree algorithm is preferred when the pattern is relatively large
and the text is relatively small. It is also useful when there are many
patterns to search for, as the algorithm can search for all patterns in
the same tree.</p>
<p>Overall, both algorithms have their own strengths and weaknesses, and
the choice of which algorithm to use depends on the specific problem at
hand.</p>
<p>Here are some practice exercises on string algorithms:</p>
<h2 id="exercises-7">Exercises</h2>
<ol type="1">
<li>Write a function in Golang to implement the Knuth-Morris-Pratt
algorithm for string searching.</li>
<li>Write a function in Golang to implement the Boyer-Moore algorithm
for string searching.</li>
<li>Write a function in Golang to implement the Rabin-Karp algorithm for
string matching.</li>
<li>Write a function in Golang to build a suffix tree for a given
string.</li>
<li>Write a function in Golang to find all occurrences of a pattern in a
given string using suffix tree algorithm.</li>
<li>Write a function in Golang to implement the Longest Common
Subsequence (LCS) problem using dynamic programming.</li>
<li>Write a function in Golang to implement the Longest Palindromic
Subsequence problem using dynamic programming.</li>
<li>Write a function in Golang to implement the Longest Palindromic
Substring problem using dynamic programming.</li>
<li>Write a function in Golang to implement the Edit Distance problem
using dynamic programming.</li>
<li>Write a function in Golang to implement the Z algorithm for pattern
searching.</li>
</ol>
<h1 id="chapter-11-tree-algorithms">Chapter 11: Tree Algorithms</h1>
<p>A tree data structure is a collection of nodes connected by edges to
form a hierarchical structure. Each node can have zero or more child
nodes, except the root node which has no parent node. Trees have
applications in many areas including:</p>
<ol type="1">
<li>File system navigation: A file system is often represented as a tree
with directories as nodes and files as leaves.</li>
<li>Organizational structure: A company’s hierarchy can be represented
as a tree with the CEO as the root node and employees as child
nodes.</li>
<li>Representing arithmetic expressions: Arithmetic expressions can be
represented as binary trees with operators as internal nodes and
operands as leaves.</li>
<li>Computer network routing: A network topology can be represented as a
tree with nodes representing routers and edges representing
connections.</li>
<li>Database indexing: Many database indexing structures such as B-trees
and AVL trees are based on the tree data structure.</li>
<li>Artificial intelligence: Decision trees are often used in artificial
intelligence for decision making.</li>
<li>Linguistics: Syntax trees are used to represent the structure of
sentences in natural language processing.</li>
<li>Web page structure: The structure of a web page can be represented
as a tree with the HTML document as the root node and the elements as
child nodes.</li>
<li>Game trees: Trees are often used in game theory to represent the
possible moves and outcomes of a game.</li>
<li>Evolutionary biology: Phylogenetic trees are used to represent the
evolutionary relationships between different species.</li>
</ol>
<p>Traversal algorithms are used to visit each node of a tree in a
specific order. The three commonly used traversal algorithms for binary
trees are:</p>
<ol type="1">
<li>Pre-order traversal: In pre-order traversal, we visit the current
node first, then its left child, and then its right child. The algorithm
can be defined recursively as follows:</li>
</ol>
<pre class="golang"><code>function preorder(node):
 if node is not null:
 visit(node)
 preorder(node.left)
 preorder(node.right)</code></pre>
<ol start="2" type="1">
<li>In-order traversal: In in-order traversal, we visit the left child
of the current node first, then the current node, and then its right
child. The algorithm can be defined recursively as follows:</li>
</ol>
<pre class="golang"><code>function inorder(node):
 if node is not null:
 inorder(node.left)
 visit(node)
 inorder(node.right)</code></pre>
<ol start="3" type="1">
<li>Post-order traversal: In post-order traversal, we visit the left
child of the current node first, then its right child, and then the
current node. The algorithm can be defined recursively as follows:</li>
</ol>
<pre class="golang"><code>function postorder(node):
 if node is not null:
 postorder(node.left)
 postorder(node.right)
 visit(node)</code></pre>
<p>These traversal algorithms can be used to perform various operations
on the tree such as printing the tree, calculating the height of the
tree, or searching for a node in the tree.</p>
<p>Tree balancing algorithms are used to balance binary search trees,
which ensures that the height of the tree is minimized and the search,
insert and delete operations are efficient. Two commonly used tree
balancing algorithms are:</p>
<ol type="1">
<li>AVL tree: An AVL tree is a binary search tree that is balanced such
that the heights of the left and right subtrees of any node differ by at
most one. When a node is inserted or deleted from the tree, it is
checked for balance and if it is unbalanced, it is rotated to maintain
the balance. There are four types of rotations: left-rotate,
right-rotate, left-right-rotate, and right-left-rotate. The rotations
are performed based on the difference in height between the left and
right subtrees. AVL tree provides faster searching than binary search
tree, but slower insertion and deletion.</li>
<li>Red-black tree: A red-black tree is another type of binary search
tree that is balanced using a color scheme to designate each node as
either red or black. The tree is balanced by ensuring that there are no
two adjacent red nodes and that the tree is height balanced. When a node
is inserted or deleted from the tree, it is recolored and rotated to
maintain the balance. There are two types of rotations: left-rotate and
right-rotate. Red-black tree provides faster searching than AVL tree,
and faster insertion and deletion.</li>
</ol>
<p>Both AVL tree and red-black tree are used in databases, operating
systems, and other applications where fast searching and efficient
insert and delete operations are required.</p>
<p>Here are some practice exercises related to tree data structures:</p>
<h2 id="exercises-8">Exercises</h2>
<ol type="1">
<li>Implement a binary search tree in Golang and perform pre-order,
in-order, and post-order traversals.</li>
<li>Implement an AVL tree in Golang and demonstrate its self-balancing
properties by inserting and deleting nodes.</li>
<li>Implement a red-black tree in Golang and demonstrate its
self-balancing properties by inserting and deleting nodes.</li>
<li>Given a binary tree, write a function to determine whether it is a
binary search tree.</li>
<li>Given a binary tree, write a function to find the maximum value in
the tree.</li>
<li>Given a binary search tree, write a function to find the kth
smallest element in the tree.</li>
<li>Given a binary tree, write a function to find the lowest common
ancestor of two nodes.</li>
<li>Given a binary tree, write a function to find the diameter of the
tree (i.e., the length of the longest path between any two nodes).</li>
<li>Given a binary tree, write a function to check whether it is
balanced (i.e., the heights of the two subtrees of any node never differ
by more than one).</li>
<li>Given a binary tree, write a function to flatten it into a linked
list in-place (i.e., the left child of each node should be null, and the
right child should point to the next node in the list).</li>
</ol>
<h1 id="chapter-12-hashing-algorithms">Chapter 12: Hashing
Algorithms</h1>
<p>Hashing is a technique of mapping large data into small keys that
could be easily searched in constant time. It is widely used in computer
science for its ability to provide constant-time operations, such as
insertions, deletions, and lookups.</p>
<p>Hashing has various applications, some of which are:</p>
<ol type="1">
<li>Storing data: Hashing is used for storing data in databases and data
structures such as hash tables and dictionaries.</li>
<li>Cryptography: Hashing is used in cryptography to secure data by
converting a message or data into a fixed-size string, which is a hash
value. Hash functions are used for digital signatures, message
authentication codes, and password storage.</li>
<li>Data compression: Hashing is used in data compression algorithms
such as Rabin-Karp and Lempel-Ziv-Welch.</li>
<li>Searching algorithms: Hashing is used in searching algorithms such
as hash tables, which are used to search for data in constant time.</li>
<li>Load balancing: Hashing is used in load balancing algorithms to
distribute data evenly across multiple servers.</li>
</ol>
<p>These are just a few examples of how hashing is used in computer
science. Its versatility and efficiency make it an important tool for
solving many computational problems.</p>
<p>A hash function is a function that takes in a data element and
returns a fixed-size value representing the original data. The resulting
value is known as a hash code or hash value. Collision occurs when two
or more data elements produce the same hash value.</p>
<p>There are several collision resolution techniques, including:</p>
<ol type="1">
<li>Separate Chaining: In this technique, each hash table index points
to a linked list. If a collision occurs, the collided item is added to
the linked list at that index. This method is simple but may require
more memory due to the need to store the linked lists.</li>
<li>Open Addressing: In this technique, if a collision occurs, the hash
function is recomputed to find the next available slot. This can be done
in several ways, such as linear probing, quadratic probing, and double
hashing.</li>
<li>Cuckoo Hashing: In this technique, each element has two possible
hash locations. If one location is already occupied, the element is
moved to its alternate location. This process is repeated until either
an empty slot is found or the number of moves exceeds a predefined
threshold. If the threshold is exceeded, the table is resized and the
elements are rehashed.</li>
</ol>
<p>A hash table is a data structure that is used to store and retrieve
values using a key. It uses a hash function to map the key to an index
of an array where the value is stored. The hash function converts the
key into an integer value that is used as an index in the array. The
value is stored at that index. Hash tables provide constant time
complexity for operations such as insert, delete and search.</p>
<p>In Golang, we can implement a hash table using a map. A map is a
built-in type in Golang that provides key-value storage.</p>
<p>Here is an example implementation of a hash table in Golang:</p>
<pre class="golang"><code>package main

import &quot;fmt&quot;

func main() {
 // create a hash table using a map
 hashTable := make(map[int]string)

 // add elements to the hash table
 hashTable[1] = &quot;John&quot;
 hashTable[2] = &quot;Jane&quot;
 hashTable[3] = &quot;Bob&quot;

 // print the hash table
 fmt.Println(hashTable)

 // delete an element from the hash table
 delete(hashTable, 2)

 // print the hash table after deletion
 fmt.Println(hashTable)

 // search for an element in the hash table
 if val, ok := hashTable[1]; ok {
 fmt.Println(&quot;Value found:&quot;, val)
 } else {
 fmt.Println(&quot;Value not found&quot;)
 }
}</code></pre>
<p>Output:</p>
<pre class="golang"><code>map[1:John 2:Jane 3:Bob]
map[1:John 3:Bob]
Value found: John</code></pre>
<p>In the above example, we create a hash table using a map and add
elements to it. We then print the hash table and delete an element from
it. Finally, we search for an element in the hash table using its
key.</p>
<p>Here are some practice exercises:</p>
<h2 id="exercises-9">Exercises</h2>
<ol type="1">
<li>Implement a hash table that supports the following operations:
insert(key, value), get(key), and delete(key).</li>
<li>Write a function that takes in an array of integers and finds the
first non-repeated integer using a hash table.</li>
<li>Given a string, find the longest substring without repeating
characters using a hash table.</li>
<li>Implement a hash table using linear probing as the collision
resolution technique.</li>
<li>Write a function that takes in two strings and determines whether
they are anagrams of each other using a hash table.</li>
<li>Given a list of words, group them by their anagrams using a hash
table.</li>
<li>Write a function that takes in a list of integers and returns the k
most frequent integers using a hash table.</li>
<li>Implement a hash table that supports resizing when the load factor
exceeds a certain threshold.</li>
<li>Given a list of strings, find the group of strings that are
rotations of each other using a hash table.</li>
<li>Write a function that takes in a list of words and returns the words
that are palindromes using a hash table.</li>
</ol>
<h1 id="chapter-13-advanced-topics">Chapter 13: Advanced Topics</h1>
<p>Parallel algorithms refer to algorithms that can execute multiple
tasks simultaneously or in parallel, typically in a shared-memory or
distributed system. They are designed to take advantage of the available
resources and minimize the execution time of the algorithms. Parallel
algorithms can be used in a wide range of applications, including
scientific simulations, data mining, and machine learning.</p>
<p>Some examples of parallel algorithms and their applications are:</p>
<ol type="1">
<li>Parallel Matrix Multiplication: This algorithm involves splitting
the matrix into smaller sub-matrices and performing the multiplication
of these sub-matrices in parallel. This algorithm is used in scientific
simulations, data analytics, and machine learning.</li>
<li>Parallel Sorting Algorithms: Parallel sorting algorithms involve
dividing the input data into smaller subsets and sorting them
independently in parallel. This approach can significantly reduce the
time complexity of sorting algorithms and is used in many applications,
including databases, data mining, and machine learning.</li>
<li>Parallel Search Algorithms: These algorithms are used to search for
specific items in large data sets. They involve dividing the data set
into smaller subsets and searching each subset in parallel. Parallel
search algorithms are commonly used in web search engines, databases,
and machine learning.</li>
<li>Parallel Convolution: This algorithm is used to perform convolution
in parallel. Convolution is an important operation in signal processing
and is used in many applications, including image and audio
processing.</li>
<li>Parallel Graph Algorithms: These algorithms are used to solve
problems related to graph theory, such as finding the shortest path
between two nodes or finding a minimum spanning tree. They involve
dividing the graph into smaller subgraphs and processing them
independently in parallel.</li>
</ol>
<p>Overall, parallel algorithms are essential in today’s computing
landscape to handle the vast amount of data generated and to speed up
processing times.</p>
<p>Approximation algorithms are a class of algorithms that find an
approximate solution for a given problem, usually within a certain
degree of accuracy. These algorithms are commonly used in optimization
problems, where finding an exact solution may not be feasible or
practical.</p>
<p>Some examples of approximation algorithms and their applications
are:</p>
<ol type="1">
<li>Greedy approximation algorithms: These algorithms make locally
optimal choices at each step to arrive at a suboptimal solution. They
are commonly used in problems such as the Knapsack problem, Traveling
Salesman Problem, and Vertex Cover problem.</li>
<li>Randomized approximation algorithms: These algorithms use
randomization to arrive at an approximate solution. They are commonly
used in problems such as Max-Cut, Set Cover, and Steiner Tree.</li>
<li>Linear programming-based approximation algorithms: These algorithms
use linear programming techniques to obtain an approximate solution.
They are commonly used in problems such as Max-Flow, Min-Cut, and Vertex
Cover.</li>
<li>Iterative approximation algorithms: These algorithms iteratively
refine an initial solution until an approximate solution is obtained.
They are commonly used in problems such as the Maximum Independent Set
problem, Minimum Vertex Cover problem, and Maximum Clique problem.</li>
<li>Heuristic approximation algorithms: These algorithms use a heuristic
function to guide the search towards an approximate solution. They are
commonly used in problems such as the Traveling Salesman Problem,
Vehicle Routing Problem, and Bin Packing Problem.</li>
</ol>
<p>Overall, approximation algorithms provide a valuable tool for solving
many real-world optimization problems where exact solutions may be
infeasible or impractical to obtain.</p>
<p>Randomized algorithms are those algorithms that use a random number
to make decisions or take actions during their execution. These
algorithms are useful in various applications, such as cryptography,
machine learning, data analysis, and optimization. Here are some
examples of randomized algorithms and their applications:</p>
<ol type="1">
<li>Randomized quicksort: Quicksort is a popular sorting algorithm that
has an average case time complexity of O(n log n). However, its
worst-case time complexity is O(n^2), which can happen when the input is
already sorted. To avoid this worst-case scenario, we can use a
randomized version of quicksort, where we choose a random element as the
pivot. This algorithm has an expected time complexity of O(n log n) and
is widely used in practice.</li>
<li>Monte Carlo method: The Monte Carlo method is a statistical method
that uses random sampling to solve problems. It is used in a wide range
of applications, such as simulation, optimization, and finance. For
example, we can use the Monte Carlo method to estimate the value of pi
by randomly throwing darts at a circle inscribed in a square. The ratio
of the number of darts that fall inside the circle to the total number
of darts gives an approximation of pi.</li>
<li>Randomized rounding: Randomized rounding is a technique used to
convert fractional solutions of linear programming problems into
integral solutions. It is used in various applications, such as
scheduling, network design, and facility location. For example, suppose
we have a set of facilities and a set of customers, and we want to find
the minimum cost set of facilities to serve all customers. We can model
this problem as a linear programming problem and use randomized rounding
to obtain an approximate solution.</li>
<li>Bloom filter: A Bloom filter is a data structure used to test
whether an element is a member of a set. It uses a bit array and
multiple hash functions to store and query the set. Bloom filters are
widely used in applications where memory usage is critical, such as
network routers and database systems.</li>
<li>Randomized search trees: Randomized search trees are binary search
trees that use randomization to maintain balance and achieve good
performance in expected time. They are used in various applications,
such as data structures for text editors and garbage collectors.</li>
</ol>
<p>These are just a few examples of randomized algorithms and their
applications. Randomized algorithms have become increasingly popular due
to their simplicity, efficiency, and versatility.</p>
<h1 id="appendix-solutions-to-exercises">Appendix: Solutions to
Exercises</h1>
<h2 id="chapter-1-solutions">Chapter 1 Solutions</h2>
<ol type="1">
<li>Solution for FizzBuzz program:</li>
</ol>
<div class="sourceCode" id="cb48"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">100</span><span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i<span class="op">%</span><span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i<span class="op">%</span><span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>            fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;FizzBuzz&quot;</span><span class="op">)</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> i<span class="op">%</span><span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>            fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Fizz&quot;</span><span class="op">)</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> i<span class="op">%</span><span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>            fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Buzz&quot;</span><span class="op">)</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>            fmt<span class="op">.</span>Println<span class="op">(</span>i<span class="op">)</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>2.Solution for counting vowels program:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">(</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;strings&quot;</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> str <span class="dt">string</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Enter a string:&quot;</span><span class="op">)</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Scanln<span class="op">(&amp;</span>str<span class="op">)</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    count <span class="op">:=</span> <span class="dv">0</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    vowels <span class="op">:=</span> <span class="st">&quot;aeiouAEIOU&quot;</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _<span class="op">,</span> char <span class="op">:=</span> <span class="kw">range</span> str <span class="op">{</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> strings<span class="op">.</span>ContainsRune<span class="op">(</span>vowels<span class="op">,</span> char<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Number of vowels: %d&quot;</span><span class="op">,</span> count<span class="op">)</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="3" type="1">
<li>Solution for summing integers program:</li>
</ol>
<div class="sourceCode" id="cb50"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> num<span class="op">,</span> sum <span class="dt">int</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Enter integers (type a non-integer value to exit):&quot;</span><span class="op">)</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>        _<span class="op">,</span> err <span class="op">:=</span> fmt<span class="op">.</span>Scan<span class="op">(&amp;</span>num<span class="op">)</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">+=</span> num</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Sum of the integers: %d&quot;</span><span class="op">,</span> sum<span class="op">)</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="4" type="1">
<li></li>
</ol>
<div class="sourceCode" id="cb51"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">(</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;bufio&quot;</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;os&quot;</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> strs <span class="op">[]</span><span class="dt">string</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    scanner <span class="op">:=</span> bufio<span class="op">.</span>NewScanner<span class="op">(</span>os<span class="op">.</span>Stdin<span class="op">)</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Enter strings (type &#39;exit&#39; to finish input):&quot;</span><span class="op">)</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> scanner<span class="op">.</span>Scan<span class="op">()</span> <span class="op">{</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>        text <span class="op">:=</span> scanner<span class="op">.</span>Text<span class="op">()</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> text <span class="op">==</span> <span class="st">&quot;exit&quot;</span> <span class="op">{</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>        strs <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>strs<span class="op">,</span> text<span class="op">)</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>    longest <span class="op">:=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _<span class="op">,</span> str <span class="op">:=</span> <span class="kw">range</span> strs <span class="op">{</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span><span class="op">(</span>str<span class="op">)</span> <span class="op">&gt;</span> <span class="bu">len</span><span class="op">(</span>longest<span class="op">)</span> <span class="op">{</span></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>            longest <span class="op">=</span> str</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Longest string: %s&quot;</span><span class="op">,</span> longest<span class="op">)</span></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="5" type="1">
<li>Solution for checking even/odd program:</li>
</ol>
<div class="sourceCode" id="cb52"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> num <span class="dt">int</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Enter a number:&quot;</span><span class="op">)</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Scanln<span class="op">(&amp;</span>num<span class="op">)</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num<span class="op">%</span><span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Even&quot;</span><span class="op">)</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Odd&quot;</span><span class="op">)</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="6" type="1">
<li>Solution for finding largest/smallest integers program:</li>
</ol>
<div class="sourceCode" id="cb53"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> nums <span class="op">[]</span><span class="dt">int</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> num <span class="dt">int</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Enter integers (type a non-integer value to exit):&quot;</span><span class="op">)</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>        _<span class="op">,</span> err <span class="op">:=</span> fmt<span class="op">.</span>Scan<span class="op">(&amp;</span>num<span class="op">)</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>        nums <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>nums<span class="op">,</span> num<span class="op">)</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span><span class="op">(</span>nums<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;No integers entered.&quot;</span><span class="op">)</span></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>    largest <span class="op">:=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>    smallest <span class="op">:=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _<span class="op">,</span> num <span class="op">:=</span> <span class="kw">range</span> nums <span class="op">{</span></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num <span class="op">&gt;</span> largest <span class="op">{</span></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>            largest <span class="op">=</span> num</span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num <span class="op">&lt;</span> smallest <span class="op">{</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>            smallest <span class="op">=</span> num</span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Largest integer: %d</span><span class="ch">\n</span><span class="st">&quot;</span><span class="op">,</span> largest<span class="op">)</span></span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Smallest integer: %d&quot;</span><span class="op">,</span> smallest<span class="op">)</span></span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="7" type="1">
<li>Solution for printing even integers program:</li>
</ol>
<div class="sourceCode" id="cb54"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> n <span class="dt">int</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Enter the number of integers:&quot;</span><span class="op">)</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Scan<span class="op">(&amp;</span>n<span class="op">)</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">int</span><span class="op">,</span> n<span class="op">)</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Enter the integers:&quot;</span><span class="op">)</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">.</span>Scan<span class="op">(&amp;</span>arr<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;Even integers in the list:&quot;</span><span class="op">)</span></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _<span class="op">,</span> num <span class="op">:=</span> <span class="kw">range</span> arr <span class="op">{</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num<span class="op">%</span><span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>            fmt<span class="op">.</span>Println<span class="op">(</span>num<span class="op">)</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="8" type="1">
<li>Solution for printing prime numbers program:</li>
</ol>
<div class="sourceCode" id="cb55"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">(</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>    strList <span class="op">:=</span> <span class="op">[]</span><span class="dt">string</span><span class="op">{</span><span class="st">&quot;apple&quot;</span><span class="op">,</span> <span class="st">&quot;banana&quot;</span><span class="op">,</span> <span class="st">&quot;cherry&quot;</span><span class="op">,</span> <span class="st">&quot;date&quot;</span><span class="op">,</span> <span class="st">&quot;elderberry&quot;</span><span class="op">}</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="bu">len</span><span class="op">(</span>strList<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--</span> <span class="op">{</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">.</span>Println<span class="op">(</span>strList<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Output:</p>
<pre><code>
elderberry
date
cherry
banana
apple</code></pre>
<p>Solution to 9</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">(</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;sort&quot;</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    intList <span class="op">:=</span> <span class="op">[]</span><span class="dt">int</span><span class="op">{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">6</span><span class="op">}</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">.</span>Ints<span class="op">(</span>intList<span class="op">)</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> median <span class="dt">float64</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span><span class="op">(</span>intList<span class="op">)%</span><span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">:=</span> <span class="bu">len</span><span class="op">(</span>intList<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>        median <span class="op">=</span> <span class="dt">float64</span><span class="op">(</span>intList<span class="op">[</span>mid<span class="op">-</span><span class="dv">1</span><span class="op">]+</span>intList<span class="op">[</span>mid<span class="op">])</span> <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">:=</span> <span class="bu">len</span><span class="op">(</span>intList<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>        median <span class="op">=</span> <span class="dt">float64</span><span class="op">(</span>intList<span class="op">[</span>mid<span class="op">])</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Median: %.2f&quot;</span><span class="op">,</span> median<span class="op">)</span></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Median: 6.00</p>
<ol start="10" type="1">
<li>Solution to 10</li>
</ol>
<div class="sourceCode" id="cb58"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">(</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;strings&quot;</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    input <span class="op">:=</span> <span class="st">&quot;Hello, World!&quot;</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    vowels <span class="op">:=</span> <span class="op">[]</span><span class="dt">string</span><span class="op">{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;e&quot;</span><span class="op">,</span> <span class="st">&quot;i&quot;</span><span class="op">,</span> <span class="st">&quot;o&quot;</span><span class="op">,</span> <span class="st">&quot;u&quot;</span><span class="op">,</span> <span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;E&quot;</span><span class="op">,</span> <span class="st">&quot;I&quot;</span><span class="op">,</span> <span class="st">&quot;O&quot;</span><span class="op">,</span> <span class="st">&quot;U&quot;</span><span class="op">}</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _<span class="op">,</span> v <span class="op">:=</span> <span class="kw">range</span> vowels <span class="op">{</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>        input <span class="op">=</span> strings<span class="op">.</span>ReplaceAll<span class="op">(</span>input<span class="op">,</span> v<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">)</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span>input<span class="op">)</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Output: Hll, Wrld!</p>
<h2 id="chapter-3-solutions">Chapter 3 Solutions</h2>
<ol start="2" type="1">
<li>Here’s an example solution in Golang that generates an array of n
integers with random values between 0 and 1000, sorts the array using
the bubble sort algorithm, and prints out the sorted array:</li>
</ol>
<div class="sourceCode" id="cb59"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">(</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;math/rand&quot;</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;time&quot;</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Generate an array of n integers with random values between 0 and 1000</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>    n <span class="op">:=</span> <span class="dv">10000</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">int</span><span class="op">,</span> n<span class="op">)</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>    rand<span class="op">.</span>Seed<span class="op">(</span>time<span class="op">.</span>Now<span class="op">().</span>UnixNano<span class="op">())</span></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> rand<span class="op">.</span>Intn<span class="op">(</span><span class="dv">1000</span><span class="op">)</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sort the array using the bubble sort algorithm</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>    start <span class="op">:=</span> time<span class="op">.</span>Now<span class="op">()</span></span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">-</span><span class="dv">1</span><span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">-</span>i<span class="op">-</span><span class="dv">1</span><span class="op">;</span> j<span class="op">++</span> <span class="op">{</span></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr<span class="op">[</span>j<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">{</span></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a>                arr<span class="op">[</span>j<span class="op">],</span> arr<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">],</span> arr<span class="op">[</span>j<span class="op">]</span></span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>    end <span class="op">:=</span> time<span class="op">.</span>Now<span class="op">()</span></span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Print out the sorted array and the time taken to sort it</span></span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Sorted array: %v</span><span class="ch">\n</span><span class="st">&quot;</span><span class="op">,</span> arr<span class="op">)</span></span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Time taken: %v</span><span class="ch">\n</span><span class="st">&quot;</span><span class="op">,</span> end<span class="op">.</span>Sub<span class="op">(</span>start<span class="op">))</span></span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This program generates an array of 10,000 integers with random values
between 0 and 1000, sorts the array using the bubble sort algorithm, and
prints out the sorted array and the time taken to sort it. You can
modify the n variable to generate arrays of different sizes and try
different sorting algorithms to compare their performance.</p>
<ol start="3" type="1">
<li>Implement a stable sorting algorithm of your choice in Golang, and
compare it with an unstable sorting algorithm (e.g. quicksort). What is
the difference between a stable and unstable sorting algorithm, and when
might you prefer one over the other?</li>
</ol>
<p>A stable sorting algorithm is one that preserves the relative order
of equal elements in the input array. In other words, if there are two
elements with the same value in the input array, their order in the
sorted array will be the same as their order in the input array. On the
other hand, an unstable sorting algorithm does not guarantee this
property.</p>
<p>One example of a stable sorting algorithm is merge sort, which works
by dividing the input array into two halves, sorting each half
recursively, and then merging the sorted halves back together. Because
the merging step takes into account the relative order of equal
elements, merge sort is stable.</p>
<p>To compare the performance of merge sort with an unstable sorting
algorithm, let’s use quicksort as an example. Quicksort is a popular
sorting algorithm that works by partitioning the input array into two
parts based on a pivot element, and then recursively sorting each part.
While quicksort has an average-case time complexity of O(n log n), it
can degenerate to O(n^2) in the worst case.</p>
<p>Here is an implementation of merge sort and quicksort in Golang:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> mergeSort<span class="op">(</span>arr <span class="op">[]</span><span class="dt">int</span><span class="op">)</span> <span class="op">[]</span><span class="dt">int</span> <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span><span class="op">(</span>arr<span class="op">)</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">:=</span> <span class="bu">len</span><span class="op">(</span>arr<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    left <span class="op">:=</span> mergeSort<span class="op">(</span>arr<span class="op">[:</span>mid<span class="op">])</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    right <span class="op">:=</span> mergeSort<span class="op">(</span>arr<span class="op">[</span>mid<span class="op">:])</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merge<span class="op">(</span>left<span class="op">,</span> right<span class="op">)</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> merge<span class="op">(</span>left<span class="op">,</span> right <span class="op">[]</span><span class="dt">int</span><span class="op">)</span> <span class="op">[]</span><span class="dt">int</span> <span class="op">{</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>    result <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">int</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="bu">len</span><span class="op">(</span>left<span class="op">)+</span><span class="bu">len</span><span class="op">(</span>right<span class="op">))</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="bu">len</span><span class="op">(</span>left<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">||</span> <span class="bu">len</span><span class="op">(</span>right<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span><span class="op">(</span>left<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">append</span><span class="op">(</span>result<span class="op">,</span> right<span class="op">...)</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span><span class="op">(</span>right<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">append</span><span class="op">(</span>result<span class="op">,</span> left<span class="op">...)</span></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> left<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;=</span> right<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">{</span></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>result<span class="op">,</span> left<span class="op">[</span><span class="dv">0</span><span class="op">])</span></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a>            left <span class="op">=</span> left<span class="op">[</span><span class="dv">1</span><span class="op">:]</span></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>result<span class="op">,</span> right<span class="op">[</span><span class="dv">0</span><span class="op">])</span></span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> right<span class="op">[</span><span class="dv">1</span><span class="op">:]</span></span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-28"><a href="#cb60-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb60-29"><a href="#cb60-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb60-30"><a href="#cb60-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-31"><a href="#cb60-31" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> quickSort<span class="op">(</span>arr <span class="op">[]</span><span class="dt">int</span><span class="op">)</span> <span class="op">[]</span><span class="dt">int</span> <span class="op">{</span></span>
<span id="cb60-32"><a href="#cb60-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span><span class="op">(</span>arr<span class="op">)</span> <span class="op">&lt;=</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb60-33"><a href="#cb60-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr</span>
<span id="cb60-34"><a href="#cb60-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-35"><a href="#cb60-35" aria-hidden="true" tabindex="-1"></a>    pivot <span class="op">:=</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb60-36"><a href="#cb60-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> left<span class="op">,</span> right <span class="op">[]</span><span class="dt">int</span></span>
<span id="cb60-37"><a href="#cb60-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _<span class="op">,</span> v <span class="op">:=</span> <span class="kw">range</span> arr<span class="op">[</span><span class="dv">1</span><span class="op">:]</span> <span class="op">{</span></span>
<span id="cb60-38"><a href="#cb60-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="op">&lt;=</span> pivot <span class="op">{</span></span>
<span id="cb60-39"><a href="#cb60-39" aria-hidden="true" tabindex="-1"></a>            left <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>left<span class="op">,</span> v<span class="op">)</span></span>
<span id="cb60-40"><a href="#cb60-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb60-41"><a href="#cb60-41" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>right<span class="op">,</span> v<span class="op">)</span></span>
<span id="cb60-42"><a href="#cb60-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb60-43"><a href="#cb60-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-44"><a href="#cb60-44" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> quickSort<span class="op">(</span>left<span class="op">)</span></span>
<span id="cb60-45"><a href="#cb60-45" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> quickSort<span class="op">(</span>right<span class="op">)</span></span>
<span id="cb60-46"><a href="#cb60-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">append</span><span class="op">(</span><span class="bu">append</span><span class="op">(</span>left<span class="op">,</span> pivot<span class="op">),</span> right<span class="op">...)</span></span>
<span id="cb60-47"><a href="#cb60-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To test the performance of these algorithms, we can generate a large
input array of random integers and measure the time it takes to sort it.
Here is an example:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">(</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;math/rand&quot;</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;time&quot;</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Generate an input array of 1 million random integers</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    n <span class="op">:=</span> <span class="dv">1000000</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">int</span><span class="op">,</span> n<span class="op">)</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> rand<span class="op">.</span>Intn<span class="op">(</span><span class="dv">1000</span><span class="op">)</span></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sort the array using merge sort and measure the time</span></span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>    start <span class="op">:=</span> time<span class="op">.</span>Now<span class="op">()</span></span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    sorted <span class="op">:=</span> mergeSort<span class="op">(</span>arr<span class="op">)</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>    elapsed <span class="op">:=</span> time<span class="op">.</span>Since<span class="op">(</span>start<span class="op">)</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Merge sort took %s to sort %d elements</span><span class="ch">\n</span><span class="st">&quot;</span><span class="op">,</span> elapsed<span class="op">,</span> n<span class="op">)</span></span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sort the array using quicksort and measure the time</span></span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> time<span class="op">.</span>Now<span class="op">()</span></span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a>    sorted <span class="op">=</span> quickSort<span class="op">(</span>arr<span class="op">)</span></span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>    elapsed <span class="op">=</span> time<span class="op">.</span>Since<span class="op">(</span>start<span class="op">)</span></span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Quicksort took %s to sort %d elements</span><span class="ch">\n</span><span class="st">&quot;</span><span class="op">,</span> elapsed<span class="op">,</span> n<span class="op">)</span></span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When we run this program, we might see that the stable sorting
algorithm produces a different output compared to the unstable sorting
algorithm. In particular, the stable sorting algorithm will preserve the
relative order of elements with equal values, while the unstable sorting
algorithm may not.</p>
<p>For example, consider the input array [3, 1, 3, 2]. If we sort this
array using the stable counting sort algorithm, we get [1, 2, 3, 3],
where the two 3’s maintain their relative order. However, if we sort the
same array using an unstable sorting algorithm like quicksort, we may
get [1, 2, 3, 3] or [1, 3, 2, 3], where the relative order of the two
3’s may be different.</p>
<p>In general, a stable sorting algorithm is preferred when we want to
preserve the relative order of equal elements in the input array. For
example, when we are sorting a list of students based on their grades,
we may want to preserve the order of students with the same grade. On
the other hand, an unstable sorting algorithm may be preferred when we
do not care about the relative order of equal elements, or when we want
to achieve better performance or use less memory.</p>
<p>It is worth noting that some unstable sorting algorithms can be
modified to become stable, but this may come at a cost of increased time
complexity or memory usage. For example, quicksort can be modified to
become stable by using a stable partitioning algorithm, but this may
result in a time complexity of O(n log n) instead of O(n log n) for the
original quicksort algorithm.</p>
<ol start="4" type="1">
<li>Suppose you are given two arrays A and B, each containing n
integers. Write a function in Golang that returns an array C containing
all the elements from A and B, sorted in ascending order. You may assume
that both A and B are already sorted.</li>
</ol>
<div class="sourceCode" id="cb62"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> mergeSortedArrays<span class="op">(</span>a <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> b <span class="op">[]</span><span class="dt">int</span><span class="op">)</span> <span class="op">[]</span><span class="dt">int</span> <span class="op">{</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    c <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">int</span><span class="op">,</span> <span class="bu">len</span><span class="op">(</span>a<span class="op">)+</span><span class="bu">len</span><span class="op">(</span>b<span class="op">))</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    i<span class="op">,</span> j<span class="op">,</span> k <span class="op">:=</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>a<span class="op">)</span> <span class="op">&amp;&amp;</span> j <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> b<span class="op">[</span>j<span class="op">]</span> <span class="op">{</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>            c<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> a<span class="op">[</span>i<span class="op">]</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>            i<span class="op">++</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>            c<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>j<span class="op">]</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>            j<span class="op">++</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>        k<span class="op">++</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>        c<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> a<span class="op">[</span>i<span class="op">]</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>        i<span class="op">++</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>        k<span class="op">++</span></span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>        c<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>j<span class="op">]</span></span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a>        j<span class="op">++</span></span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a>        k<span class="op">++</span></span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span>
<span id="cb62-25"><a href="#cb62-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The function takes two integer arrays, a and b, as input and returns
a new integer array c that contains all the elements from a and b,
sorted in ascending order. It does this by comparing the first elements
of a and b and selecting the smaller one to add to c. It then moves to
the next element of the array from which the smaller element was taken
and continues the process until all elements from both arrays have been
added to c.</p>
<p>The function has a time complexity of O(n), where n is the total
number of elements in a and b, as it only loops through each element
once.</p>
<ol start="5" type="1">
<li>To find the k-th smallest element in an array, we can use the
quickselect algorithm. This algorithm is similar to quicksort, but
instead of sorting the whole array, we only partition it based on a
pivot element until the k-th smallest element is found.</li>
</ol>
<p>Here is the Golang code for the function:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> findKthSmallest<span class="op">(</span>arr <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> k <span class="dt">int</span><span class="op">)</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> k <span class="op">&gt;</span> <span class="bu">len</span><span class="op">(</span>arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span> <span class="co">// k is out of bounds</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    left<span class="op">,</span> right <span class="op">:=</span> <span class="dv">0</span><span class="op">,</span> <span class="bu">len</span><span class="op">(</span>arr<span class="op">)-</span><span class="dv">1</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>        pivotIndex <span class="op">:=</span> left <span class="op">+</span> rand<span class="op">.</span>Intn<span class="op">(</span>right<span class="op">-</span>left<span class="op">+</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>        pivotIndex <span class="op">=</span> partition<span class="op">(</span>arr<span class="op">,</span> left<span class="op">,</span> right<span class="op">,</span> pivotIndex<span class="op">)</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k<span class="op">-</span><span class="dv">1</span> <span class="op">==</span> pivotIndex <span class="op">{</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> arr<span class="op">[</span>pivotIndex<span class="op">]</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> k<span class="op">-</span><span class="dv">1</span> <span class="op">&lt;</span> pivotIndex <span class="op">{</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> pivotIndex <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>            left <span class="op">=</span> pivotIndex <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> partition<span class="op">(</span>arr <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> left<span class="op">,</span> right<span class="op">,</span> pivotIndex <span class="dt">int</span><span class="op">)</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>    pivotValue <span class="op">:=</span> arr<span class="op">[</span>pivotIndex<span class="op">]</span></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>    arr<span class="op">[</span>pivotIndex<span class="op">],</span> arr<span class="op">[</span>right<span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span>right<span class="op">],</span> arr<span class="op">[</span>pivotIndex<span class="op">]</span></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>    storeIndex <span class="op">:=</span> left</span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> left<span class="op">;</span> i <span class="op">&lt;</span> right<span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> pivotValue <span class="op">{</span></span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>            arr<span class="op">[</span>i<span class="op">],</span> arr<span class="op">[</span>storeIndex<span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span>storeIndex<span class="op">],</span> arr<span class="op">[</span>i<span class="op">]</span></span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a>            storeIndex<span class="op">++</span></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>    arr<span class="op">[</span>storeIndex<span class="op">],</span> arr<span class="op">[</span>right<span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span>right<span class="op">],</span> arr<span class="op">[</span>storeIndex<span class="op">]</span></span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> storeIndex</span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The function findKthSmallest takes an array arr and an integer k as
input, and returns the k-th smallest element in the array. The function
first checks if k is out of bounds (i.e., greater than the length of the
array). If k is valid, the function selects a random pivot element and
partitions the array around the pivot until the k-th smallest element is
found.</p>
<p>The partition function is a helper function that partitions the array
around a pivot element. It swaps the pivot element with the rightmost
element of the array, and then iterates through the array from left to
right. For each element that is less than the pivot value, it swaps that
element with the current store index and increments the store index.
Finally, it swaps the pivot element with the element at the store index,
and returns the index of the pivot element after partitioning.</p>
<h2 id="chapter-4-excerise">Chapter 4 Excerise</h2>
<ol type="1">
<li>Implement a function <code>linearSearchString</code> that performs
linear search on an array of strings, and returns the index of the
target string, or -1 if the target is not found. The function should
have the signature:</li>
</ol>
<div class="sourceCode" id="cb64"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> linearSearchString<span class="op">(</span>arr <span class="op">[]</span><span class="dt">string</span><span class="op">,</span> target <span class="dt">string</span><span class="op">)</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>arr<span class="op">);</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> target <span class="op">{</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> i</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The function takes an array of strings arr and a target string
target. It loops through each element of the array, checking if it is
equal to the target string. If a match is found, it returns the index of
the element. If no match is found, it returns -1.</p>
<ol start="2" type="1">
<li>Implement a function <code>binarySearchFloat64</code> that performs
binary search on an array of float64 values, and returns the index of
the target value, or -1 if the target is not found. The function should
have the signature:</li>
</ol>
<div class="sourceCode" id="cb65"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> binarySearchFloat64<span class="op">(</span>arr <span class="op">[]</span><span class="dt">float64</span><span class="op">,</span> target <span class="dt">float64</span><span class="op">)</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    low <span class="op">:=</span> <span class="dv">0</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    high <span class="op">:=</span> <span class="bu">len</span><span class="op">(</span>arr<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> low <span class="op">&lt;=</span> high <span class="op">{</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">:=</span> <span class="op">(</span>low <span class="op">+</span> high<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr<span class="op">[</span>mid<span class="op">]</span> <span class="op">==</span> target <span class="op">{</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mid</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> arr<span class="op">[</span>mid<span class="op">]</span> <span class="op">&lt;</span> target <span class="op">{</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>            low <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>            high <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The function takes an array of float64 values as the first argument
and the target value as the second argument. It uses the binary search
algorithm to find the target value in the array, and returns its index
if it is found, or -1 if it is not found.</p>
<p>Note that like the linearSearchString function, this function assumes
that the input array is sorted in ascending order.</p>
<ol start="3" type="1">
<li>Implement a function <code>interpolationSearchInt</code> that
performs interpolation search on an array of int values, and returns the
index of the target value, or -1 if the target is not found. The
function should have the signature:</li>
</ol>
<div class="sourceCode" id="cb66"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> interpolationSearchInt<span class="op">(</span>arr <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> target <span class="dt">int</span><span class="op">)</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    low<span class="op">,</span> high <span class="op">:=</span> <span class="dv">0</span><span class="op">,</span> <span class="bu">len</span><span class="op">(</span>arr<span class="op">)-</span><span class="dv">1</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> low <span class="op">&lt;=</span> high <span class="op">&amp;&amp;</span> target <span class="op">&gt;=</span> arr<span class="op">[</span>low<span class="op">]</span> <span class="op">&amp;&amp;</span> target <span class="op">&lt;=</span> arr<span class="op">[</span>high<span class="op">]</span> <span class="op">{</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">:=</span> low <span class="op">+</span> <span class="op">((</span>target <span class="op">-</span> arr<span class="op">[</span>low<span class="op">])</span> <span class="op">*</span> <span class="op">(</span>high <span class="op">-</span> low<span class="op">))</span> <span class="op">/</span> <span class="op">(</span>arr<span class="op">[</span>high<span class="op">]</span> <span class="op">-</span> arr<span class="op">[</span>low<span class="op">])</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr<span class="op">[</span>pos<span class="op">]</span> <span class="op">==</span> target <span class="op">{</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr<span class="op">[</span>pos<span class="op">]</span> <span class="op">&lt;</span> target <span class="op">{</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>            low <span class="op">=</span> pos <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>            high <span class="op">=</span> pos <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This function first sets the range of the search to the entire array,
and then calculates the position of the target value by using
interpolation formula:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>pos <span class="op">:=</span> low <span class="op">+</span> <span class="op">((</span>target <span class="op">-</span> arr<span class="op">[</span>low<span class="op">])</span> <span class="op">*</span> <span class="op">(</span>high <span class="op">-</span> low<span class="op">))</span> <span class="op">/</span> <span class="op">(</span>arr<span class="op">[</span>high<span class="op">]</span> <span class="op">-</span> arr<span class="op">[</span>low<span class="op">])</span></span></code></pre></div>
<p>This formula calculates the approximate position of the target value
by estimating its location between the low and high bounds based on its
value. If the target value is found at this position, the function
returns its index. Otherwise, it adjusts the range of the search based
on whether the target value is greater or less than the value at the
calculated position, and repeats the process until either the target
value is found or the search range is exhausted.</p>
<h2 id="chapter-5-recursion-and-backtracking-1">Chapter 5: Recursion and
Backtracking</h2>
<p>Solution for problem 1: Solve the Sudoku puzzle using
backtracking.</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Helper function to check if it is possible to place a number at a given position</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> isSafe<span class="op">(</span>grid <span class="op">[</span><span class="dv">9</span><span class="op">][</span><span class="dv">9</span><span class="op">]</span><span class="dt">int</span><span class="op">,</span> row <span class="dt">int</span><span class="op">,</span> col <span class="dt">int</span><span class="op">,</span> num <span class="dt">int</span><span class="op">)</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check row</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">9</span><span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> grid<span class="op">[</span>row<span class="op">][</span>i<span class="op">]</span> <span class="op">==</span> num <span class="op">{</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check column</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">9</span><span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> grid<span class="op">[</span>i<span class="op">][</span>col<span class="op">]</span> <span class="op">==</span> num <span class="op">{</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check box</span></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>    boxRow <span class="op">:=</span> row <span class="op">-</span> row<span class="op">%</span><span class="dv">3</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>    boxCol <span class="op">:=</span> col <span class="op">-</span> col<span class="op">%</span><span class="dv">3</span></span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> boxRow<span class="op">;</span> i <span class="op">&lt;</span> boxRow<span class="op">+</span><span class="dv">3</span><span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="op">:=</span> boxCol<span class="op">;</span> j <span class="op">&lt;</span> boxCol<span class="op">+</span><span class="dv">3</span><span class="op">;</span> j<span class="op">++</span> <span class="op">{</span></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> num <span class="op">{</span></span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb68-28"><a href="#cb68-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-29"><a href="#cb68-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb68-30"><a href="#cb68-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-31"><a href="#cb68-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-32"><a href="#cb68-32" aria-hidden="true" tabindex="-1"></a><span class="co">// Helper function to find the next empty cell in the grid</span></span>
<span id="cb68-33"><a href="#cb68-33" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> findEmptyCell<span class="op">(</span>grid <span class="op">[</span><span class="dv">9</span><span class="op">][</span><span class="dv">9</span><span class="op">]</span><span class="dt">int</span><span class="op">)</span> <span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">bool</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-34"><a href="#cb68-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">9</span><span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb68-35"><a href="#cb68-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">9</span><span class="op">;</span> j<span class="op">++</span> <span class="op">{</span></span>
<span id="cb68-36"><a href="#cb68-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb68-37"><a href="#cb68-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> i<span class="op">,</span> j<span class="op">,</span> <span class="ot">true</span></span>
<span id="cb68-38"><a href="#cb68-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb68-39"><a href="#cb68-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb68-40"><a href="#cb68-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-41"><a href="#cb68-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="ot">false</span></span>
<span id="cb68-42"><a href="#cb68-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-43"><a href="#cb68-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-44"><a href="#cb68-44" aria-hidden="true" tabindex="-1"></a><span class="co">// Function to solve the Sudoku puzzle using backtracking</span></span>
<span id="cb68-45"><a href="#cb68-45" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> solveSudoku<span class="op">(</span>grid <span class="op">[</span><span class="dv">9</span><span class="op">][</span><span class="dv">9</span><span class="op">]</span><span class="dt">int</span><span class="op">)</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb68-46"><a href="#cb68-46" aria-hidden="true" tabindex="-1"></a>    row<span class="op">,</span> col<span class="op">,</span> found <span class="op">:=</span> findEmptyCell<span class="op">(</span>grid<span class="op">)</span></span>
<span id="cb68-47"><a href="#cb68-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">!</span>found <span class="op">{</span></span>
<span id="cb68-48"><a href="#cb68-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb68-49"><a href="#cb68-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-50"><a href="#cb68-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="op">:=</span> <span class="dv">1</span><span class="op">;</span> num <span class="op">&lt;=</span> <span class="dv">9</span><span class="op">;</span> num<span class="op">++</span> <span class="op">{</span></span>
<span id="cb68-51"><a href="#cb68-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> isSafe<span class="op">(</span>grid<span class="op">,</span> row<span class="op">,</span> col<span class="op">,</span> num<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-52"><a href="#cb68-52" aria-hidden="true" tabindex="-1"></a>            grid<span class="op">[</span>row<span class="op">][</span>col<span class="op">]</span> <span class="op">=</span> num</span>
<span id="cb68-53"><a href="#cb68-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> solveSudoku<span class="op">(</span>grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-54"><a href="#cb68-54" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb68-55"><a href="#cb68-55" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb68-56"><a href="#cb68-56" aria-hidden="true" tabindex="-1"></a>            grid<span class="op">[</span>row<span class="op">][</span>col<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb68-57"><a href="#cb68-57" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb68-58"><a href="#cb68-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-59"><a href="#cb68-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb68-60"><a href="#cb68-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-61"><a href="#cb68-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-62"><a href="#cb68-62" aria-hidden="true" tabindex="-1"></a><span class="co">// Function to print the Sudoku grid</span></span>
<span id="cb68-63"><a href="#cb68-63" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> printSudoku<span class="op">(</span>grid <span class="op">[</span><span class="dv">9</span><span class="op">][</span><span class="dv">9</span><span class="op">]</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-64"><a href="#cb68-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">9</span><span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb68-65"><a href="#cb68-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">9</span><span class="op">;</span> j<span class="op">++</span> <span class="op">{</span></span>
<span id="cb68-66"><a href="#cb68-66" aria-hidden="true" tabindex="-1"></a>            fmt<span class="op">.</span>Print<span class="op">(</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> <span class="st">&quot; &quot;</span><span class="op">)</span></span>
<span id="cb68-67"><a href="#cb68-67" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb68-68"><a href="#cb68-68" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">.</span>Println<span class="op">()</span></span>
<span id="cb68-69"><a href="#cb68-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-70"><a href="#cb68-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="2" type="1">
<li>Write a function to solve the N-Queens problem using
backtracking.</li>
</ol>
<p>Here’s a possible implementation of a function to solve the N-Queens
problem using backtracking in Golang:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="co">// function to check if a queen can be placed at position (row, col) in the board</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> isSafe<span class="op">(</span>board <span class="op">[][]</span><span class="dt">bool</span><span class="op">,</span> row<span class="op">,</span> col<span class="op">,</span> N <span class="dt">int</span><span class="op">)</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// check if there is a queen in the same column</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> row<span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> board<span class="op">[</span>i<span class="op">][</span>col<span class="op">]</span> <span class="op">{</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// check if there is a queen in the upper-left diagonal</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i<span class="op">,</span> j <span class="op">:=</span> row<span class="op">-</span><span class="dv">1</span><span class="op">,</span> col<span class="op">-</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">,</span> j <span class="op">=</span> i<span class="op">-</span><span class="dv">1</span><span class="op">,</span> j<span class="op">-</span><span class="dv">1</span> <span class="op">{</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> board<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">{</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// check if there is a queen in the upper-right diagonal</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i<span class="op">,</span> j <span class="op">:=</span> row<span class="op">-</span><span class="dv">1</span><span class="op">,</span> col<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">,</span> j <span class="op">=</span> i<span class="op">-</span><span class="dv">1</span><span class="op">,</span> j<span class="op">+</span><span class="dv">1</span> <span class="op">{</span></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> board<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">{</span></span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// if all checks pass, the queen can be placed at this position</span></span>
<span id="cb69-29"><a href="#cb69-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb69-30"><a href="#cb69-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb69-31"><a href="#cb69-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-32"><a href="#cb69-32" aria-hidden="true" tabindex="-1"></a><span class="co">// function to solve the N-Queens problem using backtracking</span></span>
<span id="cb69-33"><a href="#cb69-33" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> solveNQueens<span class="op">(</span>N <span class="dt">int</span><span class="op">)</span> <span class="op">[][]</span><span class="dt">string</span> <span class="op">{</span></span>
<span id="cb69-34"><a href="#cb69-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// initialize the board with no queens placed</span></span>
<span id="cb69-35"><a href="#cb69-35" aria-hidden="true" tabindex="-1"></a>    board <span class="op">:=</span> <span class="bu">make</span><span class="op">([][]</span><span class="dt">bool</span><span class="op">,</span> N<span class="op">)</span></span>
<span id="cb69-36"><a href="#cb69-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="kw">range</span> board <span class="op">{</span></span>
<span id="cb69-37"><a href="#cb69-37" aria-hidden="true" tabindex="-1"></a>        board<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">bool</span><span class="op">,</span> N<span class="op">)</span></span>
<span id="cb69-38"><a href="#cb69-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-39"><a href="#cb69-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-40"><a href="#cb69-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// recursive function to place queens in the board</span></span>
<span id="cb69-41"><a href="#cb69-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> backtrack <span class="kw">func</span><span class="op">(</span>row <span class="dt">int</span><span class="op">,</span> board <span class="op">[][]</span><span class="dt">bool</span><span class="op">,</span> solutions <span class="op">*[][]</span><span class="dt">string</span><span class="op">)</span></span>
<span id="cb69-42"><a href="#cb69-42" aria-hidden="true" tabindex="-1"></a>    backtrack <span class="op">=</span> <span class="kw">func</span><span class="op">(</span>row <span class="dt">int</span><span class="op">,</span> board <span class="op">[][]</span><span class="dt">bool</span><span class="op">,</span> solutions <span class="op">*[][]</span><span class="dt">string</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-43"><a href="#cb69-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// if all queens have been placed, add the solution to the solutions array</span></span>
<span id="cb69-44"><a href="#cb69-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> row <span class="op">==</span> N <span class="op">{</span></span>
<span id="cb69-45"><a href="#cb69-45" aria-hidden="true" tabindex="-1"></a>            solution <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">string</span><span class="op">,</span> N<span class="op">)</span></span>
<span id="cb69-46"><a href="#cb69-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb69-47"><a href="#cb69-47" aria-hidden="true" tabindex="-1"></a>                rowStr <span class="op">:=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb69-48"><a href="#cb69-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> j <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> N<span class="op">;</span> j<span class="op">++</span> <span class="op">{</span></span>
<span id="cb69-49"><a href="#cb69-49" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> board<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">{</span></span>
<span id="cb69-50"><a href="#cb69-50" aria-hidden="true" tabindex="-1"></a>                        rowStr <span class="op">+=</span> <span class="st">&quot;Q&quot;</span></span>
<span id="cb69-51"><a href="#cb69-51" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb69-52"><a href="#cb69-52" aria-hidden="true" tabindex="-1"></a>                        rowStr <span class="op">+=</span> <span class="st">&quot;.&quot;</span></span>
<span id="cb69-53"><a href="#cb69-53" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb69-54"><a href="#cb69-54" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb69-55"><a href="#cb69-55" aria-hidden="true" tabindex="-1"></a>                solution<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> rowStr</span>
<span id="cb69-56"><a href="#cb69-56" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb69-57"><a href="#cb69-57" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>solutions <span class="op">=</span> <span class="bu">append</span><span class="op">(*</span>solutions<span class="op">,</span> solution<span class="op">)</span></span>
<span id="cb69-58"><a href="#cb69-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb69-59"><a href="#cb69-59" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb69-60"><a href="#cb69-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-61"><a href="#cb69-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">// try placing a queen in each column of the current row</span></span>
<span id="cb69-62"><a href="#cb69-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> col <span class="op">&lt;</span> N<span class="op">;</span> col<span class="op">++</span> <span class="op">{</span></span>
<span id="cb69-63"><a href="#cb69-63" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> isSafe<span class="op">(</span>board<span class="op">,</span> row<span class="op">,</span> col<span class="op">,</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-64"><a href="#cb69-64" aria-hidden="true" tabindex="-1"></a>                <span class="co">// place the queen and recursively try placing the remaining queens</span></span>
<span id="cb69-65"><a href="#cb69-65" aria-hidden="true" tabindex="-1"></a>                board<span class="op">[</span>row<span class="op">][</span>col<span class="op">]</span> <span class="op">=</span> <span class="ot">true</span></span>
<span id="cb69-66"><a href="#cb69-66" aria-hidden="true" tabindex="-1"></a>                backtrack<span class="op">(</span>row<span class="op">+</span><span class="dv">1</span><span class="op">,</span> board<span class="op">,</span> solutions<span class="op">)</span></span>
<span id="cb69-67"><a href="#cb69-67" aria-hidden="true" tabindex="-1"></a>                board<span class="op">[</span>row<span class="op">][</span>col<span class="op">]</span> <span class="op">=</span> <span class="ot">false</span> <span class="co">// backtrack</span></span>
<span id="cb69-68"><a href="#cb69-68" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb69-69"><a href="#cb69-69" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb69-70"><a href="#cb69-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-71"><a href="#cb69-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-72"><a href="#cb69-72" aria-hidden="true" tabindex="-1"></a>    <span class="co">// find all solutions to the N-Queens problem</span></span>
<span id="cb69-73"><a href="#cb69-73" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> solutions <span class="op">[][]</span><span class="dt">string</span></span>
<span id="cb69-74"><a href="#cb69-74" aria-hidden="true" tabindex="-1"></a>    backtrack<span class="op">(</span><span class="dv">0</span><span class="op">,</span> board<span class="op">,</span> <span class="op">&amp;</span>solutions<span class="op">)</span></span>
<span id="cb69-75"><a href="#cb69-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-76"><a href="#cb69-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> solutions</span>
<span id="cb69-77"><a href="#cb69-77" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb69-78"><a href="#cb69-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-79"><a href="#cb69-79" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb69-80"><a href="#cb69-80" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve the 4-Queens problem and print the solutions</span></span>
<span id="cb69-81"><a href="#cb69-81" aria-hidden="true" tabindex="-1"></a>    solutions <span class="op">:=</span> solveNQueens<span class="op">(</span><span class="dv">4</span><span class="op">)</span></span>
<span id="cb69-82"><a href="#cb69-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _<span class="op">,</span> solution <span class="op">:=</span> <span class="kw">range</span> solutions <span class="op">{</span></span>
<span id="cb69-83"><a href="#cb69-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _<span class="op">,</span> row <span class="op">:=</span> <span class="kw">range</span> solution <span class="op">{</span></span>
<span id="cb69-84"><a href="#cb69-84" aria-hidden="true" tabindex="-1"></a>            fmt<span class="op">.</span>Println<span class="op">(</span>row<span class="op">)</span></span>
<span id="cb69-85"><a href="#cb69-85" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb69-86"><a href="#cb69-86" aria-hidden="true" tabindex="-1"></a>        fmt<span class="op">.</span>Println<span class="op">()</span></span>
<span id="cb69-87"><a href="#cb69-87" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-88"><a href="#cb69-88" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This implementation uses a recursive function backtrack to place
queens in the board, starting from the top row and working its way down.
At each row, the function tries placing a queen in each column, and
checks if it is safe to place a queen in that position using the isSafe
function. If a safe position is found, the function places the queen and
recursively tries placing the remaining queens.</p>
<ol start="3" type="1">
<li>Here’s an implementation of a function to solve the Subset Sum
problem using backtracking in Golang:</li>
</ol>
<div class="sourceCode" id="cb70"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a><span class="co">// subsetSumBacktracking finds all subsets of the input set that add up to the target sum.</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> subsetSumBacktracking<span class="op">(</span>set <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> target <span class="dt">int</span><span class="op">)</span> <span class="op">[][]</span><span class="dt">int</span> <span class="op">{</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create an empty 2D slice to store the subsets that add up to the target sum.</span></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> result <span class="op">[][]</span><span class="dt">int</span></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Recursive backtracking function to find the subsets.</span></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> backtrack <span class="kw">func</span><span class="op">(</span>remaining <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> current <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> sum <span class="dt">int</span><span class="op">)</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>    backtrack <span class="op">=</span> <span class="kw">func</span><span class="op">(</span>remaining <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> current <span class="op">[]</span><span class="dt">int</span><span class="op">,</span> sum <span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sum <span class="op">==</span> target <span class="op">{</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// If the sum of the current subset equals the target sum, add it to the result slice.</span></span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>result<span class="op">,</span> <span class="bu">append</span><span class="op">([]</span><span class="dt">int</span><span class="op">(</span><span class="ot">nil</span><span class="op">),</span> current<span class="op">...))</span></span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sum <span class="op">&gt;</span> target <span class="op">{</span></span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// If the sum of the current subset exceeds the target sum, terminate the recursion.</span></span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb70-24"><a href="#cb70-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-25"><a href="#cb70-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Iterate over the remaining elements in the input set.</span></span>
<span id="cb70-26"><a href="#cb70-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i<span class="op">,</span> num <span class="op">:=</span> <span class="kw">range</span> remaining <span class="op">{</span></span>
<span id="cb70-27"><a href="#cb70-27" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Create a new slice containing the remaining elements after the current element.</span></span>
<span id="cb70-28"><a href="#cb70-28" aria-hidden="true" tabindex="-1"></a>            rest <span class="op">:=</span> remaining<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">:]</span></span>
<span id="cb70-29"><a href="#cb70-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-30"><a href="#cb70-30" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Create a new slice containing the current subset with the current element.</span></span>
<span id="cb70-31"><a href="#cb70-31" aria-hidden="true" tabindex="-1"></a>            next <span class="op">:=</span> <span class="bu">append</span><span class="op">(</span>current<span class="op">,</span> num<span class="op">)</span></span>
<span id="cb70-32"><a href="#cb70-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-33"><a href="#cb70-33" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Recursively call the backtrack function with the remaining elements and the current subset.</span></span>
<span id="cb70-34"><a href="#cb70-34" aria-hidden="true" tabindex="-1"></a>            backtrack<span class="op">(</span>rest<span class="op">,</span> next<span class="op">,</span> sum<span class="op">+</span>num<span class="op">)</span></span>
<span id="cb70-35"><a href="#cb70-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb70-36"><a href="#cb70-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-37"><a href="#cb70-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-38"><a href="#cb70-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Call the backtrack function with the input set, an empty current subset, and a sum of 0.</span></span>
<span id="cb70-39"><a href="#cb70-39" aria-hidden="true" tabindex="-1"></a>    backtrack<span class="op">(</span>set<span class="op">,</span> <span class="op">[]</span><span class="dt">int</span><span class="op">{},</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb70-40"><a href="#cb70-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-41"><a href="#cb70-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb70-42"><a href="#cb70-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb70-43"><a href="#cb70-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-44"><a href="#cb70-44" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb70-45"><a href="#cb70-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Example usage:</span></span>
<span id="cb70-46"><a href="#cb70-46" aria-hidden="true" tabindex="-1"></a>    set <span class="op">:=</span> <span class="op">[]</span><span class="dt">int</span><span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">10</span><span class="op">}</span></span>
<span id="cb70-47"><a href="#cb70-47" aria-hidden="true" tabindex="-1"></a>    target <span class="op">:=</span> <span class="dv">15</span></span>
<span id="cb70-48"><a href="#cb70-48" aria-hidden="true" tabindex="-1"></a>    result <span class="op">:=</span> subsetSumBacktracking<span class="op">(</span>set<span class="op">,</span> target<span class="op">)</span></span>
<span id="cb70-49"><a href="#cb70-49" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span>result<span class="op">)</span> <span class="co">// Output: [[3 4 8] [5 10] [7 8]]</span></span>
<span id="cb70-50"><a href="#cb70-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The subsetSumBacktracking function takes an input set and a target
sum, and returns a 2D slice containing all the subsets of the input set
that add up to the target sum. The function uses a recursive
backtracking algorithm to generate all possible subsets, and checks if
each subset’s sum equals the target sum. If so, the subset is added to
the result slice.</p>
<p>Here’s an implementation of a function to find all possible
permutations of a given set of numbers using backtracking in Go:</p>
<pre class="golang"><code>package main

import &quot;fmt&quot;

// backtrackPermute generates all possible permutations of nums
func backtrackPermute(nums []int, perm []int, used []bool, res *[][]int) {
 if len(perm) == len(nums) {
 // Add permutation to results
 *res = append(*res, append([]int{}, perm...))
 return
 }
 for i := 0; i &lt; len(nums); i++ {
 if used[i] {
 continue
 }
 perm = append(perm, nums[i])
 used[i] = true
 backtrackPermute(nums, perm, used, res)
 used[i] = false
 perm = perm[:len(perm)-1]
 }
}

// permute returns all possible permutations of nums
func permute(nums []int) [][]int {
 res := [][]int{}
 perm := []int{}
 used := make([]bool, len(nums))
 backtrackPermute(nums, perm, used, &amp;res)
 return res
}

func main() {
 nums := []int{1, 2, 3}
 res := permute(nums)
 fmt.Println(res) // Output: [[1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]]
}</code></pre>
<p>The <code>backtrackPermute</code> function generates all possible
permutations of <code>nums</code> by trying out all possible
combinations of elements in the array using backtracking. The
<code>perm</code> slice stores the current permutation being
constructed, while <code>used</code> is a boolean array indicating which
elements have been used in the current permutation. When a complete
permutation has been generated, it is added to the results
<code>res</code>.</p>
<p>The <code>permute</code> function initializes the results
<code>res</code> slice, and calls <code>backtrackPermute</code> to
generate all permutations of the input <code>nums</code>.</p>
<p>In the <code>main</code> function, we call <code>permute</code> with
an example input slice of <code>[1, 2, 3]</code>, and print the
resulting permutations to the console.</p>
<p>Here’s an implementation of a function to find all possible
combinations of a given set of numbers that add up to a target sum using
backtracking in Golang:</p>
<pre class="golang"><code>func combinationSum(candidates []int, target int) [][]int {
 res := [][]int{}
 combination := []int{}
 backtrackCombinationSum(candidates, target, combination, &amp;res, 0)
 return res
}

func backtrackCombinationSum(candidates []int, target int, combination []int, res *[][]int, start int) {
 if target &lt; 0 {
 return
 } else if target == 0 {
 temp := make([]int, len(combination))
 copy(temp, combination)
 *res = append(*res, temp)
 } else {
 for i := start; i &lt; len(candidates); i++ {
 combination = append(combination, candidates[i])
 backtrackCombinationSum(candidates, target-candidates[i], combination, res, i)
 combination = combination[:len(combination)-1]
 }
 }
}</code></pre>
<p>The <code>combinationSum</code> function takes in a slice of integers
<code>candidates</code> and an integer <code>target</code>, and returns
a slice of slices of integers containing all possible combinations of
<code>candidates</code> that add up to <code>target</code>.</p>
<p>The function initializes an empty slice <code>res</code> to hold the
results, and an empty slice <code>combination</code> to hold the current
combination being considered. It then calls the
<code>backtrackCombinationSum</code> function with the initial
parameters.</p>
<p>The <code>backtrackCombinationSum</code> function takes in the same
parameters as <code>combinationSum</code>, along with an integer
<code>start</code> to indicate the starting index in the
<code>candidates</code> slice. The function checks if the current
<code>target</code> is less than 0, which means that the current
combination is invalid, and returns. If <code>target</code> is equal to
0, then the current combination is valid and is added to
<code>res</code>. Otherwise, the function loops through the
<code>candidates</code> slice, starting from the current
<code>start</code> index. For each candidate, the candidate is added to
<code>combination</code>, and the function is called recursively with
the <code>target</code> reduced by the candidate value, the
<code>combination</code> slice, and the current index as the new
<code>start</code> index. After the recursive call, the candidate is
removed from <code>combination</code>, and the loop continues with the
next candidate.</p>
<p>The function uses a backtracking approach, where it tries out
different combinations of candidates and tracks the ones that add up to
the target sum. At each step, it adds a candidate to the combination,
and checks if the sum is still less than or equal to the target. If it
is, it recurses to the next step with the reduced target sum and the
updated combination. If the sum is greater than the target, it
backtracks by removing the last candidate from the combination and tries
the next candidate.</p>
<p>Overall, this algorithm has a time complexity of O(2^n), since it
generates all possible combinations of candidates. However, by using
backtracking, it is able to prune some branches of the recursion tree,
making it faster in practice for small to medium sized inputs.</p>
<h2 id="chapter-6-algorithmic-techniques-1">Chapter 6: Algorithmic
Techniques</h2>
<p>Divide and conquer is a problem-solving technique in computer science
and mathematics. The basic idea behind this technique is to break down a
problem into smaller, more manageable subproblems, solve them
independently, and combine the solutions to the subproblems to obtain
the solution to the original problem.</p>
<p>The divide and conquer technique is typically applied recursively,
with each level of recursion reducing the problem size by a constant
factor. This approach leads to algorithms with logarithmic or linear
time complexity.</p>
<p>A classic example of a problem that can be solved using divide and
conquer is binary search. Given a sorted array of n elements and a
target value x, the algorithm compares x with the middle element of the
array. If x is equal to the middle element, the search is complete.
Otherwise, if x is less than the middle element, the algorithm searches
the left half of the array. If x is greater than the middle element, the
algorithm searches the right half of the array. This process is repeated
until the target element is found or the search range is empty.</p>
<p>Other examples of problems that can be solved using the divide and
conquer technique include:</p>
<ul>
<li>Merge sort: a sorting algorithm that divides the input array into
two halves, sorts each half independently, and merges the sorted halves
to produce the final sorted array.</li>
<li>Quick sort: a sorting algorithm that selects a pivot element from
the input array, partitions the array into two subarrays around the
pivot, and recursively sorts the two subarrays.</li>
<li>Karatsuba multiplication: a fast algorithm for multiplying large
integers that breaks the problem down into smaller subproblems, uses
recursion to solve the subproblems, and combines the solutions using a
formula based on the original problem.</li>
</ul>
<p>The divide and conquer technique is a powerful tool for solving a
wide range of computational problems efficiently. It is widely used in
computer science, mathematics, and engineering.</p>
<p>Dynamic programming is a technique used in computer programming to
solve complex problems by breaking them down into smaller sub-problems
and solving each sub-problem only once. The results of the sub-problems
are stored in memory so that they can be accessed later if needed,
reducing the overall time complexity of the algorithm.</p>
<p>The basic idea behind dynamic programming is to solve a problem by
breaking it down into smaller sub-problems, and then reusing the
solutions to those sub-problems to solve the larger problem. This
approach is particularly useful for problems that have overlapping
sub-problems, meaning that the same sub-problem may be encountered
multiple times during the solution process.</p>
<p>There are two main approaches to dynamic programming: top-down and
bottom-up. The top-down approach, also known as memoization, involves
breaking down the problem into smaller sub-problems and solving each
sub-problem recursively. As each sub-problem is solved, its solution is
stored in a lookup table, so that if the same sub-problem is encountered
again, its solution can be retrieved from the table rather than being
solved again. The bottom-up approach, on the other hand, involves
solving the sub-problems in order from smallest to largest, and storing
the solutions in an array or table as they are solved. This approach is
sometimes called tabulation.</p>
<p>Dynamic programming is used in a wide range of applications,
including optimization problems, sequence alignment, shortest path
algorithms, and more. It is particularly useful in situations where a
problem can be broken down into smaller, more manageable sub-problems,
and where the solutions to those sub-problems can be combined to solve
the larger problem.</p>
<p>Greedy Algorithms are a class of algorithms that make locally optimal
choices at each step with the hope of finding a global optimum. In other
words, at each step of the algorithm, the decision is made based on the
current state of the problem, without considering the future
implications of that decision.</p>
<p>The greedy approach is often used in optimization problems, where the
goal is to find the optimal solution from a set of possible solutions.
This approach is simple, fast, and often provides good results, but it
is not always guaranteed to find the optimal solution.</p>
<p>Examples of problems that can be solved using greedy algorithms
include:</p>
<ol type="1">
<li>Fractional Knapsack Problem: Given a set of items, each with a
weight and a value, determine the items to include in a collection so
that the total weight is less than or equal to a given limit and the
total value is maximized.</li>
<li>Dijkstra’s Shortest Path Algorithm: Given a weighted graph, find the
shortest path from a starting vertex to all other vertices.</li>
<li>Huffman Coding: Given a set of characters and their frequencies,
construct a binary tree that minimizes the total encoding length of the
characters.</li>
<li>Activity Selection Problem: Given a set of activities, each with a
start and end time, select the maximum number of non-overlapping
activities that can be performed by a single person.</li>
<li>Minimum Spanning Tree: Given a weighted graph, find a tree that
spans all the vertices in the graph and has the minimum possible total
edge weight.</li>
</ol>
<p>Overall, the greedy approach is a useful tool for solving
optimization problems quickly and efficiently. However, it is important
to note that it is not always guaranteed to find the optimal solution,
and other approaches such as dynamic programming or divide-and-conquer
may be more appropriate in some cases.</p>
<p>Backtracking is a technique for solving problems by exploring all
possible solutions recursively, and “backtracking” to previous steps
when a dead end is reached. It is especially useful when the problem
involves making a sequence of decisions, where each decision affects
subsequent decisions, and where the goal is to find a solution that
satisfies a set of constraints.</p>
<p>The backtracking algorithm works by maintaining a candidate solution,
and incrementally building it up by making a sequence of decisions. At
each step, the algorithm checks whether the current candidate solution
satisfies the problem constraints. If it does, the algorithm continues
to the next step, otherwise it “backtracks” to the previous step and
tries a different decision.</p>
<p>Backtracking can be used to solve a wide variety of problems,
including puzzles, constraint satisfaction problems, and combinatorial
optimization problems. Some examples of problems that can be solved
using backtracking include the N-Queens problem, the Sudoku puzzle, and
the Traveling Salesman Problem.</p>
<p>One advantage of backtracking is that it can often find the optimal
solution to a problem, by exploring all possible solutions and selecting
the best one. However, the downside is that it can be very
time-consuming, since the number of possible solutions can grow
exponentially with the size of the problem.</p>
<p>To improve the performance of backtracking algorithms, a number of
optimization techniques can be used, such as pruning the search tree,
memoization, and dynamic programming.</p>
<p>Branch and Bound is a technique used in optimization problems to
systematically explore all possible solutions and arrive at the best
solution. The basic idea is to create a tree of all possible solutions,
and then prune branches that are not promising.</p>
<p>The algorithm starts with an initial feasible solution and computes
the lower and upper bounds on the objective function. It then generates
all possible extensions to the solution, and computes the bounds for
each extension. The best extension is selected and added to the current
solution, and the process is repeated until a complete solution is
found.</p>
<p>The algorithm is called “branch and bound” because it involves
branching on the search space and bounding the possible solutions to
speed up the search. The branching step involves dividing the problem
into subproblems that are easier to solve, while the bounding step
involves calculating the minimum and maximum possible values of the
objective function for each subproblem.</p>
<p>Branch and Bound is used in a wide range of optimization problems,
including scheduling, routing, resource allocation, and facility
location. It is particularly useful when the search space is large and
the objective function is non-linear and complex. The algorithm can
guarantee that the best solution is found, but it can be computationally
expensive and time-consuming, especially for large problems.</p>
<p>Sure, what kind of practice exercises would you like?</p>
<h2 id="chapter-7-graph-algorithms-1">Chapter 7: Graph Algorithms</h2>
<p>Sure, here’s an implementation of branch and bound algorithm to solve
the knapsack problem in Golang:</p>
<pre class="golang"><code>type Item struct {
 weight int
 value int
}

func Knapsack(items []Item, capacity int) int {
 sort.Slice(items, func(i, j int) bool {
 return items[i].value*items[j].weight &gt; items[j].value*items[i].weight
 })
 n := len(items)
 maxValue := 0

 var dfs func(index, value, weight int)
 dfs = func(index, value, weight int) {
 if weight &gt; capacity {
 return
 }
 if value+upperBound(items[index:], capacity-weight) &lt;= maxValue {
 return
 }
 if index == n {
 if value &gt; maxValue {
 maxValue = value
 }
 return
 }
 dfs(index+1, value, weight)
 dfs(index+1, value+items[index].value, weight+items[index].weight)
 }

 dfs(0, 0, 0)
 return maxValue
}

func upperBound(items []Item, capacity int) int {
 value := 0
 for i := range items {
 if capacity &lt; items[i].weight {
 break
 }
 value += items[i].value
 capacity -= items[i].weight
 }
 if i &lt; len(items) {
 value += capacity * items[i].value / items[i].weight
 }
 return value
}</code></pre>
<p>The <code>Knapsack</code> function takes an array of
<code>Item</code>s and a weight capacity as input, and returns the
maximum possible value of items that can fit in the knapsack.</p>
<p>The function first sorts the items in decreasing order of their
value-to-weight ratio, which allows the algorithm to explore more
promising paths first. The function then defines a <code>dfs</code>
function that performs the depth-first search with pruning. The
<code>dfs</code> function takes three arguments: the index of the
current item being considered, the current total value of items, and the
current total weight of items. If the current weight exceeds the
capacity, the function immediately returns. If the upper bound of the
maximum possible value that can be obtained by considering the remaining
items is less than or equal to the current maximum value, the function
returns without further exploration. The upper bound is calculated by
selecting items in decreasing order of their value-to-weight ratio until
the knapsack is full, and then adding a fraction of the next item that
fits in the remaining capacity based on its value-to-weight ratio. If
the function has reached the end of the items array, it updates the
maximum value if the current value is greater than the current maximum.
Finally, the function calls the <code>dfs</code> function with the
initial arguments and returns the maximum value found.</p>
<p>Note that the implementation assumes that the items array is sorted
in decreasing order of their value-to-weight ratio. This can be achieved
by pre-sorting the array or by modifying the <code>dfs</code> function
to sort the remaining items at each recursive call. Also note that this
implementation is not optimized for space efficiency, as it creates new
slices at each recursive call. A more optimized implementation could use
a fixed-size array or a stack-based approach.</p>
<p>The traveling salesman problem is a well-known NP-hard problem that
seeks to find the shortest possible route that visits each city exactly
once and returns to the starting city. A branch and bound algorithm can
be used to solve this problem, where the search space is explored by
dividing it into smaller sub-problems that can be solved more
efficiently.</p>
<p>Here’s an outline of the algorithm:</p>
<ol type="1">
<li>Generate a complete graph of the cities, where the edges represent
the distances between them.</li>
<li>Start with an initial node that represents the starting city.</li>
<li>Generate a priority queue of nodes to visit, where the priority is
determined by the lower bound of the total distance.</li>
<li>While there are nodes to visit:</li>
</ol>
<ol type="a">
<li>Pop the node with the highest priority from the queue.</li>
<li>If the node represents a complete tour, update the best solution if
it is better than the current best.</li>
<li>Otherwise, generate child nodes by adding a new city to the tour,
and compute their lower bounds.</li>
<li>Add the child nodes to the priority queue.</li>
</ol>
<ol start="5" type="1">
<li>Return the best solution found.</li>
</ol>
<p>Here’s an implementation of the algorithm in Golang:</p>
<pre class="golang"><code>package main

import (
 &quot;container/heap&quot;
 &quot;fmt&quot;
 &quot;math&quot;
)

// Define a type to represent a node in the search tree.
type node struct {
 tour []int // The cities visited so far.
 cost float64 // The total distance traveled so far.
 bound float64 // The lower bound of the total distance.
}

// Define a type to represent the priority queue of nodes.
type nodeQueue []node

// Implement the heap interface for the priority queue.
func (pq nodeQueue) Len() int { return len(pq) }
func (pq nodeQueue) Less(i, j int) bool { return pq[i].bound &lt; pq[j].bound }
func (pq nodeQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }
func (pq *nodeQueue) Push(x interface{}) {
 *pq = append(*pq, x.(node))
}
func (pq *nodeQueue) Pop() interface{} {
 old := *pq
 n := len(old)
 x := old[n-1]
 *pq = old[0 : n-1]
 return x
}

// Define a function to compute the lower bound of the total distance for a node.
func computeBound(n node, distances [][]float64) float64 {
 // Compute the cost of the edges in the tour so far.
 for i := 0; i &lt; len(n.tour)-1; i++ {
 n.cost += distances[n.tour[i]][n.tour[i+1]]
 }
 // Compute the minimum cost of adding each unvisited city to the tour.
 for i := range distances {
 if !contains(n.tour, i) {
 minDist := math.Inf(1)
 for j := range distances {
 if i != j &amp;&amp; !contains(n.tour, j) &amp;&amp; distances[i][j] &lt; minDist {
 minDist = distances[i][j]
 }
 }
 n.bound += minDist
 }
 }
 return n.bound
}

// Define a function to check if a slice contains a given element.
func contains(s []int, e int) bool {
 for _, v := range s {
 if v == e {
 return true
 }
 }
 return false
}

// Define a function to solve the traveling salesman problem using branch and bound.
func tspBB(distances [][]float64) ([]int, float64) {
 // Start with a tour that only visits the starting</code></pre>
<p>Here’s a possible implementation of a branch and bound algorithm to
solve the graph coloring problem:</p>
<pre class="golang"><code>package main

import (
 &quot;fmt&quot;
)

type Graph struct {
 vertices int
 edges [][]bool
}

func NewGraph(vertices int) *Graph {
 edges := make([][]bool, vertices)
 for i := 0; i &lt; vertices; i++ {
 edges[i] = make([]bool, vertices)
 }
 return &amp;Graph{vertices: vertices, edges: edges}
}

func (g *Graph) AddEdge(u, v int) {
 g.edges[u][v] = true
 g.edges[v][u] = true
}

func (g *Graph) IsSafe(vertex int, color int, colors []int) bool {
 for i := 0; i &lt; g.vertices; i++ {
 if g.edges[vertex][i] &amp;&amp; colors[i] == color {
 return false
 }
 }
 return true
}

func (g *Graph) ColorVerticesUtil(colors []int, vertex int, numColors int, bestColors *[]int) bool {
 if vertex == g.vertices {
 *bestColors = append([]int{}, colors...)
 return true
 }

 for i := 1; i &lt;= numColors; i++ {
 if g.IsSafe(vertex, i, colors) {
 colors[vertex] = i
 if g.ColorVerticesUtil(colors, vertex+1, numColors, bestColors) {
 return true
 }
 colors[vertex] = 0
 }
 }

 return false
}

func (g *Graph) ColorVertices(numColors int) []int {
 colors := make([]int, g.vertices)
 bestColors := make([]int, g.vertices)
 g.ColorVerticesUtil(colors, 0, numColors, &amp;bestColors)
 return bestColors
}

func main() {
 g := NewGraph(5)
 g.AddEdge(0, 1)
 g.AddEdge(0, 2)
 g.AddEdge(1, 2)
 g.AddEdge(1, 3)
 g.AddEdge(2, 3)
 g.AddEdge(3, 4)
 
 colors := g.ColorVertices(3)
 fmt.Println(colors)
}</code></pre>
<p>In this implementation, we define a <code>Graph</code> struct to
represent the graph, where <code>vertices</code> is the number of
vertices in the graph, and <code>edges</code> is a 2D slice of booleans
that indicates whether there is an edge between two vertices. We then
define methods on the <code>Graph</code> struct to add edges, check
whether a vertex can be colored with a given color, and color the
vertices using a backtracking algorithm with branch and bound.</p>
<p>The <code>IsSafe</code> method checks whether it is safe to color a
vertex with a given color, by checking whether any of its adjacent
vertices have the same color. The <code>ColorVertices</code> method
initializes an array of <code>colors</code> for each vertex, and then
calls a helper function <code>ColorVerticesUtil</code> to recursively
color the vertices using backtracking. The
<code>ColorVerticesUtil</code> function tries each possible color for
the current vertex, and then recursively colors the rest of the
vertices. If a solution is found, the function returns
<code>true</code>, and the <code>ColorVertices</code> function returns
the colors for the vertices.</p>
<p>To use this implementation, we can create a <code>Graph</code>
object, add edges between vertices, and then call the
<code>ColorVertices</code> method to get the colors for the vertices. In
the example above, we create a graph with 5 vertices and add edges
between them, and then call the <code>ColorVertices</code> method with 3
colors. The output</p>
<p>Sure, here’s an implementation of the branch and bound algorithm to
solve the subset sum problem in Go:</p>
<pre class="golang"><code>package main

import (
 &quot;fmt&quot;
 &quot;math&quot;
 &quot;sort&quot;
)

func subsetSumBB(nums []int, target int) []int {
 // Sort the numbers in decreasing order
 sort.Slice(nums, func(i, j int) bool { return nums[i] &gt; nums[j] })

 // Create a queue to hold partial solutions
 queue := make([][]int, 0)

 // Add the empty subset to the queue
 queue = append(queue, []int{})

 // Initialize the best solution and its sum
 bestSum := math.MinInt32
 bestSubset := []int{}

 for len(queue) &gt; 0 {
 // Get the next partial solution from the queue
 partial := queue[0]
 queue = queue[1:]

 // Compute the sum of the partial solution
 sum := 0
 for _, num := range partial {
 sum += num
 }

 // If the sum is greater than or equal to the target,
 // update the best solution if necessary
 if sum &gt;= target &amp;&amp; sum &gt; bestSum {
 bestSum = sum
 bestSubset = partial
 }

 // If the sum is less than the target, add new partial solutions
 if sum &lt; target {
 // Find the next unused number
 var next int
 if len(partial) &gt; 0 {
 next = partial[len(partial)-1]
 }
 for _, num := range nums {
 if num &lt; next {
 break
 }
 if contains(partial, num) {
 continue
 }
 newPartial := append([]int{}, partial...)
 newPartial = append(newPartial, num)
 queue = append(queue, newPartial)
 }
 }
 }

 return bestSubset
}

// Helper function to check if a slice contains a given element
func contains(s []int, elem int) bool {
 for _, v := range s {
 if v == elem {
 return true
 }
 }
 return false
}

func main() {
 nums := []int{10, 7, 5, 18, 12, 20, 15}
 target := 35
 subset := subsetSumBB(nums, target)
 fmt.Printf(&quot;Subset that adds up to %d: %v\n&quot;, target, subset)
}</code></pre>
<p>This implementation uses a queue to hold partial solutions, and
checks each partial solution to see if it is a valid candidate for the
best solution. If the partial solution’s sum is greater than or equal to
the target and greater than the best solution found so far, it updates
the best solution. If the partial solution’s sum is less than the
target, it generates new partial solutions by adding unused numbers in
descending order. The algorithm continues until the queue is empty.</p>
<p>Sure, here’s an implementation of a branch and bound algorithm for
the vehicle routing problem in Python:</p>
<pre class="golang"><code>import heapq
from typing import List, Tuple

def solve\_vehicle\_routing(num\_vehicles: int, start\_loc: int, demands: List[int], time\_windows: List[Tuple[int, int]], distances: List[List[int]]) -&gt; Tuple[List[List[int]], List[int]]:
 # Initialize variables
 num_locations = len(demands)
 visited = [False] * num_locations
 visited[start_loc] = True
 curr_demand = demands[start_loc]
 curr_time = 0
 curr_loc = start_loc
 routes = [[] for _ in range(num_vehicles)]
 route_demand = [0] * num_vehicles
 route_time = [0] * num_vehicles
 pq = []

 # Add initial states to priority queue
 for loc in range(num_locations):
 if loc != start_loc:
 heapq.heappush(pq, (distances[start_loc][loc], [start_loc, loc], [False] * num_locations, demands[loc], time_windows[loc], 1))

 # Branch and bound loop
 while pq:
 _, path, visited_states, demand, time_window, depth = heapq.heappop(pq)
 if depth == num_vehicles:
 # Add final location to route
 routes[0] = path + [start_loc]
 return routes, route_time

 # Check if state is worth exploring
 if depth == 1 or demand &lt;= sum(demands) / num_vehicles:
 for loc in range(num_locations):
 if not visited_states[loc] and loc != start_loc:
 new_path = path + [loc]
 new_visited = visited_states.copy()
 new_visited[loc] = True
 new_demand = demand + demands[loc]
 new_time = max(curr_time + distances[curr_loc][loc], time_window[0])
 if new_time &lt;= time_window[1]:
 # Add new state to priority queue
 heapq.heappush(pq, (new_demand, new_path, new_visited, new_demand, time_window, depth+1)))

 return None, None</code></pre>
<p>The function takes as input the number of vehicles, the starting
location, the demands for each location, the time windows for each
location, and the distances between each pair of locations. It returns a
tuple containing the routes for each vehicle and the total time taken
for each route.</p>
<p>The algorithm starts by initializing the variables, adding the
initial states to the priority queue, and setting up the loop for the
branch and bound algorithm. In each iteration of the loop, it pops the
state with the lowest cost from the priority queue and checks if it is
worth exploring. If the state has depth equal to the number of vehicles,
it means that all vehicles have been assigned a route, so it adds the
final location to the route for the first vehicle and returns the routes
and total times. Otherwise, it generates new states by adding unvisited
locations to the current route and adding them to the priority queue if
they satisfy the demand and time window constraints.</p>
<p>Note that this implementation assumes that the demand and time window
constraints are the same for all vehicles, but it can be easily modified
to handle different constraints for each vehicle.</p>
<h2 id="chapter-8-greedy-algorithms-1">Chapter 8: Greedy Algorithms</h2>
<p>Sure! Here are implementations of Dijkstra’s algorithm and
Bellman-Ford algorithm in Golang:</p>
<p>Dijkstra’s Algorithm:</p>
<pre class="golang"><code>package main

import (
 &quot;fmt&quot;
 &quot;math&quot;
)

type Edge struct {
 to int
 weight int
}

type Graph [][]Edge

func dijkstra(g Graph, start int) []int {
 n := len(g)
 dist := make([]int, n)
 for i := range dist {
 dist[i] = math.MaxInt32
 }
 dist[start] = 0

 visited := make([]bool, n)
 for count := 0; count &lt; n-1; count++ {
 u := -1
 for i := 0; i &lt; n; i++ {
 if !visited[i] &amp;&amp; (u == -1 || dist[i] &lt; dist[u]) {
 u = i
 }
 }
 if dist[u] == math.MaxInt32 {
 break
 }
 visited[u] = true
 for _, e := range g[u] {
 if newDist := dist[u] + e.weight; newDist &lt; dist[e.to] {
 dist[e.to] = newDist
 }
 }
 }
 return dist
}

func main() {
 g := make(Graph, 5)
 g[0] = []Edge{{1, 10}, {2, 3}}
 g[1] = []Edge{{2, 1}, {3, 2}}
 g[2] = []Edge{{1, 4}, {3, 8}, {4, 2}}
 g[3] = []Edge{{4, 7}}
 g[4] = []Edge{{3, 9}}

 dist := dijkstra(g, 0)
 fmt.Println(dist)
}</code></pre>
<p>Bellman-Ford Algorithm:</p>
<pre class="golang"><code>package main

import (
 &quot;fmt&quot;
 &quot;math&quot;
)

type Edge struct {
 from int
 to int
 weight int
}

type Graph struct {
 edges []Edge
 n int
}

func bellmanFord(g Graph, start int) []int {
 dist := make([]int, g.n)
 for i := range dist {
 dist[i] = math.MaxInt32
 }
 dist[start] = 0

 for i := 0; i &lt; g.n-1; i++ {
 for _, e := range g.edges {
 if newDist := dist[e.from] + e.weight; newDist &lt; dist[e.to] {
 dist[e.to] = newDist
 }
 }
 }

 for _, e := range g.edges {
    if newDist := dist[e.from] + e.weight; newDist &lt; dist[e.to] {
        panic(&quot;negative cycle&quot;)
    }
 }

 return dist
}

func main() {
 g := Graph{
 edges: []Edge{
 {0, 1, 10},
 {0, 2, 3},
 {1, 2, 1},
 {1, 3, 2},
 {2, 1, 4},
 {2, 3, 8},
 {2, 4, 2},
 {3, 4, 7},
 {4, 3, 9},
 },
 n: 5,
 }

 dist := bellmanFord(g, 0)
 fmt.Println(dist)
}</code></pre>
<p>Sure! Here’s the implementation of Dijkstra’s algorithm in Golang to
find the shortest path from vertex 1 to all other vertices in the given
graph:</p>
<pre class="golang"><code>package main

import (
 &quot;fmt&quot;
 &quot;math&quot;
)

type Graph struct {
 nodes []int
 edges map[int]map[int]int
}

func NewGraph() *Graph {
 return &amp;Graph{
    nodes: []int{},
    edges: make(map[int]map[int]int),
 }
}

func (g *Graph) AddNode(node int) {
 g.nodes = append(g.nodes, node)
}

func (g *Graph) AddEdge(src, dst, weight int) {
 if _, ok := g.edges[src]; !ok {
    g.edges[src] = make(map[int]int)
 }
    g.edges[src][dst] = weight
}

func DijkstraShortestPath(g *Graph, start int) map[int]int {
 distances := make(map[int]int)
 for _, node := range g.nodes {
    distances[node] = math.MaxInt32
 }
 distances[start] = 0

 queue := make(map[int]int)
 queue[start] = 0

 for len(queue) != 0 {
    currNode, currDist := getMinNode(queue)
    delete(queue, currNode)

    for nextNode, weight := range g.edges[currNode] {
        distance := currDist + weight

        if distance &lt; distances[nextNode] {
            distances[nextNode] = distance
            queue[nextNode] = distance
            }
        }
    }

 return distances
}

func getMinNode(queue map[int]int) (int, int) {
 minDist := math.MaxInt32
 minNode := -1

 for node, dist := range queue {
    if dist &lt; minDist {
        minDist = dist
        minNode = node
    }
 }

 return minNode, minDist
}

func main() {
 g := NewGraph()

 for i := 1; i &lt;= 6; i++ {
    g.AddNode(i)
 }

 g.AddEdge(1, 2, 1)
 g.AddEdge(1, 3, 1)
 g.AddEdge(1, 4, 5)
 g.AddEdge(2, 3, 2)
 g.AddEdge(2, 5, 6)
 g.AddEdge(3, 6, 3)
 g.AddEdge(4, 5, 2)
 g.AddEdge(5, 6, 3)

 distances := DijkstraShortestPath(g, 1)

 fmt.Println(&quot;Shortest path from vertex 1 to all other vertices:&quot;)
 for node, dist := range distances {
    fmt.Printf(&quot;Vertex %d: %d\n&quot;, node, dist)
 }
}</code></pre>
<p>The output will be:</p>
<pre class="golang"><code>Shortest path from vertex 1 to all other vertices:
Vertex 1: 0
Vertex 2: 1
Vertex 3: 1
Vertex 4: 3
Vertex 5: 3
Vertex 6: 4</code></pre>
<p>So the shortest path from vertex 1 to vertex 6 is 4.</p>
<h2 id="chapter-9-divide-and-conquer-algorithms-1">Chapter 9: Divide and
Conquer Algorithms</h2>
<ol type="1">
<li>Implement a divide and conquer algorithm to find the maximum element
in an array</li>
</ol>
<pre class="golang"><code>func findMax(arr []int) int {
 n := len(arr)
 
 if n == 1 {
 return arr[0]
 }
 
 if n == 2 {
 if arr[0] &gt; arr[1] {
 return arr[0]
 } else {
 return arr[1]
 }
 }
 
 mid := n / 2
 leftMax := findMax(arr[:mid])
 rightMax := findMax(arr[mid:])
 
 if leftMax &gt; rightMax {
 return leftMax
 } else {
 return rightMax
 }
}</code></pre>
<p>The <code>findMax</code> function takes an array of integers and
returns the maximum element in the array. If the array has only one
element, that element is returned. If the array has two elements, the
maximum of the two is returned. Otherwise, the array is divided into two
halves and the maximum of each half is computed recursively. The maximum
of the left and right halves is then returned as the maximum of the
entire array.</p>
<p>This algorithm has a time complexity of O(n log n) and a space
complexity of O(log n), since it uses recursion to divide the array into
smaller and smaller pieces.</p>
<ol start="2" type="1">
<li>Implement a divide and conquer algorithm to count the number of
inversions in an array. An inversion is a pair of elements in the array
where the larger element appears before the smaller element.</li>
</ol>
<pre class="golang"><code>func countInversions(arr []int) (int, []int) {
 n := len(arr)
 if n &lt;= 1 {
 return 0, arr
 }
 
 mid := n / 2
 left, right := arr[:mid], arr[mid:]
 
 leftCount, sortedLeft := countInversions(left)
 rightCount, sortedRight := countInversions(right)
 
 i, j := 0, 0
 merged := make([]int, 0, n)
 inversions := leftCount + rightCount
 
 for i &lt; len(sortedLeft) &amp;&amp; j &lt; len(sortedRight) {
 if sortedLeft[i] &lt;= sortedRight[j] {
 merged = append(merged, sortedLeft[i])
 i++
 } else {
 merged = append(merged, sortedRight[j])
 j++
 inversions += len(sortedLeft) - i
 }
 }
 
 merged = append(merged, sortedLeft[i:]...)
 merged = append(merged, sortedRight[j:]...)
 
 return inversions, merged
}</code></pre>
<p>The <code>countInversions</code> function takes an array of integers
and returns the number of inversions in the array, as well as a sorted
version of the array. The function uses a modified version of the merge
sort algorithm to count the inversions.</p>
<p>The function recursively divides the input array into halves until
the base case of an array with one or zero elements is reached. The
function then merges the two halves together while counting the number
of inversions. When an element in the right half is added to the merged
array, the number of inversions is incremented by the number of elements
remaining in the left half.</p>
<p>This algorithm has a time complexity of O(n log n) and a space
complexity of O(n), since it uses recursion to divide the array and a
temporary array to store the merged subarrays.</p>
<ol start="3" type="1">
<li>Implement a divide and conquer algorithm to find the median of two
sorted arrays. The median is the middle element in the combined sorted
array.</li>
</ol>
<p>Here’s one possible implementation in Go:</p>
<pre class="golang"><code>func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
 m, n := len(nums1), len(nums2)
 if m &gt; n {
 nums1, nums2, m, n = nums2, nums1, n, m
 }
 iMin, iMax, halfLen := 0, m, (m+n+1)/2
 for iMin &lt;= iMax {
 i := (iMin + iMax) / 2
 j := halfLen - i
 if i &lt; m &amp;&amp; nums2[j-1] &gt; nums1[i] {
 iMin = i + 1
 } else if i &gt; 0 &amp;&amp; nums1[i-1] &gt; nums2[j] {
 iMax = i - 1
 } else {
 maxLeft := 0
 if i == 0 {
 maxLeft = nums2[j-1]
 } else if j == 0 {
 maxLeft = nums1[i-1]
 } else {
 maxLeft = max(nums1[i-1], nums2[j-1])
 }
 if (m+n)%2 == 1 {
 return float64(maxLeft)
 }
 minRight := 0
 if i == m {
 minRight = nums2[j]
 } else if j == n {
 minRight = nums1[i]
 } else {
 minRight = min(nums1[i], nums2[j])
 }
 return float64(maxLeft+minRight) / 2.0
 }
 }
 return 0.0
}

func max(a, b int) int {
 if a &gt; b {
 return a
 }
 return b
}

func min(a, b int) int {
 if a &lt; b {
 return a
 }
 return b
}</code></pre>
<p>This function takes two sorted arrays <code>nums1</code> and
<code>nums2</code> as input and returns the median of their combined
sorted array. The algorithm is a divide and conquer approach that first
ensures that <code>nums1</code> is the smaller array, and then uses
binary search to find the correct position of the median element. We
divide the arrays into two parts such that <code>nums1[0:i]</code> and
<code>nums2[0:j]</code> are the left parts, and <code>nums1[i:m]</code>
and <code>nums2[j:n]</code> are the right parts. The median is the
element that separates the left and right parts, which is either the
maximum element in the left parts or the minimum element in the right
parts, depending on whether the total length of the two arrays is even
or odd.</p>
<p>The time complexity of this algorithm is O(log(min(m, n))), which is
achieved by performing binary search on the smaller array. The space
complexity is O(1), since we only use constant extra space to store some
variables.</p>
<ol start="4" type="1">
<li>Implement a divide and conquer algorithm to find the kth largest
element in an unsorted array.</li>
</ol>
<p>Here’s one possible implementation in Go:</p>
<pre class="golang"><code>func findKthLargest(nums []int, k int) int {
 n := len(nums)
 left, right := 0, n-1
 for {
 pivotIdx := rand.Intn(n)
 pivotIdx = partition(nums, left, right, pivotIdx)
 if pivotIdx == k-1 {
 return nums[pivotIdx]
 } else if pivotIdx &lt; k-1 {
 left = pivotIdx + 1
 } else {
 right = pivotIdx - 1
 }
 }
}

func partition(nums []int, left, right, pivotIdx int) int {
 pivotVal := nums[pivotIdx]
 nums[pivotIdx], nums[right] = nums[right], nums[pivotIdx]
 storeIdx := left
 for i := left; i &lt; right; i++ {
 if nums[i] &gt; pivotVal {
 nums[i], nums[storeIdx] = nums[storeIdx], nums[i]
 storeIdx++
 }
 }
 nums[storeIdx], nums[right] = nums[right], nums[storeIdx]
 return storeIdx
}</code></pre>
<p>This function takes an unsorted array <code>nums</code> and an
integer <code>k</code> as input and returns the <code>k</code>th largest
element in the array. The algorithm is a divide and conquer approach
that uses a variation of the quicksort algorithm. We randomly choose an
element in the array as the pivot, and partition the array into two
parts such that all elements larger than the pivot are on the left, and
all elements smaller than the pivot are on the right. If the pivot is at
the <code>k-1</code> index, then we return it as the <code>k</code>th
largest element. Otherwise, we recursively apply the same procedure to
the left or right part of the array depending on whether the pivot is to
the left or right of the <code>k-1</code> index.</p>
<p>The time complexity of this algorithm is <span
class="math inline"><em>O</em>(<em>n</em>)</span> in the worst case and
<span
class="math inline"><em>O</em>(<em>n</em><em>l</em><em>o</em><em>g</em><em>n</em>)</span>
on average, which is achieved by performing randomized partitioning. The
space complexity is <span class="math inline"><em>O</em>(1)</span>,
since we only use constant extra space to store some variables.</p>
<p>Generating section: 5. Implement a divide and conquer algorithm to
find the closest pair of points in a set of 2D points.</p>
<p>Here’s one possible implementation in Go:</p>
<pre class="golang"><code>import (
 &quot;math&quot;
 &quot;sort&quot;
)

type Point struct {
 X, Y float64
}

func closestPair(points []Point) (float64, Point, Point) {
 n := len(points)
 if n &lt; 2 {
 return math.Inf(1), Point{}, Point{}
 }
 // Sort points by x-coordinate
 sort.Slice(points, func(i, j int) bool {
 return points[i].X &lt; points[j].X
 })
 // Recursively find closest pair in left and right halves
 mid := n / 2
 dL, pL1, pL2 := closestPair(points[:mid])
 dR, pR1, pR2 := closestPair(points[mid:])
 // Choose the closer of the two pairs
 var d float64
 var p1, p2 Point
 if dL &lt; dR {
 d, p1, p2 = dL, pL1, pL2
 } else {
 d, p1, p2 = dR, pR1, pR2
 }
 // Find the closest pair that spans the two halves
 strip := make([]Point, 0, n)
 midX := points[mid].X
 for _, p := range points {
 if math.Abs(p.X-midX) &lt; d {
 strip = append(strip, p)
 }
 }
 sort.Slice(strip, func(i, j int) bool {
 return strip[i].Y &lt; strip[j].Y
 })
 for i := 0; i &lt; len(strip)-1; i++ {
 for j := i + 1; j &lt; len(strip) &amp;&amp; strip[j].Y-strip[i].Y &lt; d; j++ {
 dist := distance(strip[i], strip[j])
 if dist &lt; d {
 d, p1, p2 = dist, strip[i], strip[j]
 }
 }
 }
 return d, p1, p2
}

func distance(p1, p2 Point) float64 {
 dx := p1.X - p2.X
 dy := p1.Y - p2.Y
 return math.Sqrt(dx*dx + dy*dy)
}</code></pre>
<p>This function takes a slice of <code>Point</code> structs as input
and returns the distance between the closest pair of points, as well as
the two points themselves. The algorithm is a divide and conquer
approach that recursively finds the closest pair of points in the left
and right halves of the point set. It then chooses the closer of the two
pairs and finds the closest pair that spans the two halves by looking at
a “strip” of points that lie within a distance <code>d</code> of the
midpoint. The points in the strip are sorted by y-coordinate, and a
nested loop is used to check all pairs of points in the strip that are
closer than <code>d</code>.</p>
<p>The time complexity of this algorithm is O(nlogn), where
<code>n</code> is the number of points, since we perform a total of
<span
class="math inline"><em>O</em>(<em>n</em><em>l</em><em>o</em><em>g</em><em>n</em>)</span>
comparisons and sorts. The space complexity is <span
class="math inline"><em>O</em>(<em>n</em>)</span>, since we create a
temporary strip array to store the points within the <code>d</code>
distance of the midpoint.</p>
<ol start="6" type="1">
<li>Implement a divide and conquer algorithm to solve the maximum
subarray problem. The maximum subarray problem is the task of finding
the contiguous subarray within a one-dimensional array, a[1…n], of
numbers which has the largest sum.</li>
</ol>
<pre class="golang"><code>func maxSubarray(arr []int) (int, int, int) {
 n := len(arr)
 if n == 1 {
 return arr[0], 0, 0
 }
 
 mid := n / 2
 leftSum, leftStart, leftEnd := maxSubarray(arr[:mid])
 rightSum, rightStart, rightEnd := maxSubarray(arr[mid:])
 
 crossSum, crossStart, crossEnd := maxCrossingSubarray(arr, mid)
 
 if leftSum &gt;= rightSum &amp;&amp; leftSum &gt;= crossSum {
 return leftSum, leftStart, leftEnd
 } else if rightSum &gt;= leftSum &amp;&amp; rightSum &gt;= crossSum {
 return rightSum, rightStart + mid, rightEnd + mid
 } else {
 return crossSum, crossStart, crossEnd
 }
}

func maxCrossingSubarray(arr []int, mid int) (int, int, int) {
 leftSum, rightSum := -1&lt;&lt;31, -1&lt;&lt;31
 sum := 0
 maxLeft, maxRight := mid, mid
 
 for i := mid - 1; i &gt;= 0; i-- {
 sum += arr[i]
 if sum &gt; leftSum {
 leftSum = sum
 maxLeft = i
 }
 }
 
 sum = 0
 
 for i := mid; i &lt; len(arr); i++ {
 sum += arr[i]
 if sum &gt; rightSum {
 rightSum = sum
 maxRight = i
 }
 }
 
 return leftSum + rightSum, maxLeft, maxRight
}</code></pre>
<p>The <code>maxSubarray</code> function takes an array of integers and
returns the sum of the maximum subarray, as well as the starting and
ending indices of the subarray. The function uses a modified version of
the divide and conquer algorithm.</p>
<p>The function recursively divides the input array into halves until
the base case of an array with one element is reached. The function then
computes the maximum subarray of the left and right halves recursively,
as well as the maximum subarray that crosses the midpoint. The function
then returns the maximum of these three subarrays.</p>
<p>The <code>maxCrossingSubarray</code> function takes an array of
integers and the index of the midpoint and returns the sum of the
maximum subarray that crosses the midpoint, as well as the starting and
ending indices of the subarray.</p>
<p>This algorithm has a time complexity of O(n log n) and a space
complexity of O(log n), since it uses recursion to divide the array into
smaller and smaller pieces.</p>
<ol start="7" type="1">
<li>Implement a divide and conquer algorithm to find the closest pair of
points in a set of 3D points.</li>
</ol>
<p>To solve this problem, we can use the Divide and Conquer algorithm.
The basic idea is to divide the set of 3D points into two halves, solve
the problem recursively in each half, and then merge the solutions.</p>
<p>The merging process involves finding the minimum distance between two
points that are split between the two halves and the minimum distance
between two points that are entirely in one of the halves.</p>
<p>Here’s the Go code implementation:</p>
<pre class="golang"><code>type Point struct {
 x, y, z float64
}

func distance(a, b Point) float64 {
 dx, dy, dz := a.x-b.x, a.y-b.y, a.z-b.z
 return math.Sqrt(dx*dx + dy*dy + dz*dz)
}

func min(a, b float64) float64 {
 if a &lt; b {
 return a
 }
 return b
}

func closestPair(points []Point) float64 {
 n := len(points)
 if n &lt; 2 {
 return math.Inf(1)
 }

 mid := n / 2
 left := points[:mid]
 right := points[mid:]

 d := min(closestPair(left), closestPair(right))

 var strip []Point
 for i := range points {
 if math.Abs(points[i].x-points[mid].x) &lt; d {
 strip = append(strip, points[i])
 }
 }

 sort.Slice(strip, func(i, j int) bool {
 return strip[i].y &lt; strip[j].y
 })

 for i := range strip {
 for j := i + 1; j &lt; len(strip) &amp;&amp; strip[j].y-strip[i].y &lt; d; j++ {
 d = min(d, distance(strip[i], strip[j]))
 }
 }

 return d
}</code></pre>
<p>In the <code>Point</code> struct, we represent each point in 3D space
with its <code>x</code>, <code>y</code>, and <code>z</code> coordinates.
The <code>distance</code> function calculates the Euclidean distance
between two points. The <code>min</code> function returns the minimum of
two float64 values.</p>
<p>The <code>closestPair</code> function takes a slice of
<code>Point</code> values as input and returns the minimum distance
between any two points in the set. The function first checks if there
are fewer than two points in the set and returns positive infinity if
there are. The function then divides the set into two halves and solves
the problem recursively in each half. The minimum distance
<code>d</code> is initialized with the minimum of the distances returned
by the recursive calls.</p>
<p>The <code>strip</code> slice is created to store the points that are
within the distance <code>d</code> from the splitting plane. This is
done by iterating over all points and checking if their <code>x</code>
coordinates are within distance <code>d</code> of the midpoint
<code>x</code> coordinate. The <code>strip</code> slice is then sorted
by the <code>y</code> coordinate of each point.</p>
<p>The nested <code>for</code> loops iterate over all pairs of points in
the <code>strip</code> slice and calculate the distance between them.
The loop continues as long as the difference in <code>y</code>
coordinates is less than <code>d</code>. If the distance between the
current pair of points is less than the current minimum distance
<code>d</code>, then <code>d</code> is updated to the new minimum
distance.</p>
<p>Overall, this algorithm has a time complexity of O(n log n) and a
space complexity of O(n).</p>
<ol start="8" type="1">
<li>Implement a divide and conquer algorithm to find the minimum element
in a rotated sorted array.</li>
</ol>
<p>Solution:</p>
<p>To solve this problem, we can use the Divide and Conquer algorithm.
The basic idea is to divide the rotated sorted array into two halves,
and then determine which half contains the minimum element. We can do
this by comparing the middle element with the last element of the array.
If the middle element is greater than the last element, then the minimum
element must be in the second half of the array. Otherwise, the minimum
element must be in the first half of the array.</p>
<p>Here’s the Go code implementation:</p>
<pre class="golang"><code>func findMin(nums []int) int {
 n := len(nums)
 if n == 1 {
 return nums[0]
 }
 if nums[0] &lt; nums[n-1] {
 return nums[0]
 }

 mid := n / 2
 if nums[mid] &gt; nums[n-1] {
 return findMin(nums[mid:])
 } else {
 return findMin(nums[:mid+1])
 }
}</code></pre>
<p>The <code>findMin</code> function takes a slice of integers as input
and returns the minimum element in the rotated sorted array. If the
array contains only one element, then that element is the minimum, and
the function returns it. Otherwise, if the first element is less than
the last element, then the array is not rotated, and the function
returns the first element.</p>
<p>Otherwise, we calculate the middle index of the array, and we compare
the middle element with the last element of the array. If the middle
element is greater than the last element, then the minimum element must
be in the second half of the array. We call the <code>findMin</code>
function recursively on the second half of the array. Otherwise, the
minimum element must be in the first half of the array. We call the
<code>findMin</code> function recursively on the first half of the
array.</p>
<p>Overall, this algorithm has a time complexity of O(log n) and a space
complexity of O(log n), where n is the size of the array.</p>
<ol start="9" type="1">
<li>Implement a divide and conquer algorithm to find the maximum sum of
a subsequence of a given sequence.</li>
</ol>
<p>Solution:</p>
<p>To solve this problem, we can use the Divide and Conquer algorithm.
The basic idea is to divide the given sequence into two halves, and then
find the maximum subsequence sum in each half. The maximum subsequence
sum can either be entirely in the left half, entirely in the right half,
or spanning across both halves. We can find the maximum subsequence sum
spanning across both halves by calculating the maximum subsequence sum
starting from the middle element and going towards the left, and the
maximum subsequence sum starting from the middle element and going
towards the right. The maximum subsequence sum spanning across both
halves is the sum of these two maximum subsequence sums.</p>
<p>Here’s the Go code implementation:</p>
<pre class="golang"><code>func maxSubsequenceSum(nums []int) int {
 n := len(nums)
 if n == 1 {
 return nums[0]
 }

 mid := n / 2
 maxLeft := maxSubsequenceSum(nums[:mid])
 maxRight := maxSubsequenceSum(nums[mid:])
 maxCrossing := maxCrossingSum(nums, mid)

 return max(maxLeft, maxRight, maxCrossing)
}

func maxCrossingSum(nums []int, mid int) int {
 leftSum := math.MinInt32
 rightSum := math.MinInt32
 sum := 0

 for i := mid - 1; i &gt;= 0; i-- {
 sum += nums[i]
 if sum &gt; leftSum {
 leftSum = sum
 }
 }

 sum = 0

 for i := mid; i &lt; len(nums); i++ {
 sum += nums[i]
 if sum &gt; rightSum {
 rightSum = sum
 }
 }

 return leftSum + rightSum
}

func max(nums ...int) int {
 res := math.MinInt32
 for _, num := range nums {
 if num &gt; res {
 res = num
 }
 }
 return res
}</code></pre>
<p>The <code>maxSubsequenceSum</code> function takes a slice of integers
as input and returns the maximum sum of a subsequence of the given
sequence. If the sequence contains only one element, then that element
is the maximum subsequence sum, and the function returns it.</p>
<p>Otherwise, we calculate the middle index of the sequence, and we find
the maximum subsequence sum in the left half and in the right half of
the sequence recursively. We also find the maximum subsequence sum
spanning across both halves by calling the <code>maxCrossingSum</code>
function.</p>
<p>The <code>maxCrossingSum</code> function takes the input sequence and
the middle index as input, and returns the maximum subsequence sum
spanning across both halves of the sequence. The function iterates from
the middle index towards the left and calculates the maximum subsequence
sum starting from the middle element and going towards the left. It also
iterates from the middle index towards the right and calculates the
maximum subsequence sum starting from the middle element and going
towards the right. The maximum subsequence sum spanning across both
halves is the sum of these two maximum subsequence sums.</p>
<p>Finally, we return the maximum of the maximum subsequence sums in the
left half, the right half, and spanning across both halves.</p>
<p>Overall, this algorithm has a time complexity of O(n log n) and a
space complexity of O(log n), where n is the size of the sequence.</p>
<ol start="10" type="1">
<li>Implement a divide and conquer algorithm to find the convex hull of
a set of points in the plane.</li>
</ol>
<p>Solution:</p>
<p>To solve this problem, we can use the Divide and Conquer algorithm
known as the “Gift Wrapping” or “Jarvis March” algorithm. The basic idea
is to start with the leftmost point in the set and then find the next
point that is the farthest counterclockwise from the current point. We
keep repeating this process until we reach the starting point, forming a
convex hull around the set of points.</p>
<p>Here’s the Go code implementation:</p>
<pre class="golang"><code>type point struct {
 x, y int
}

func convexHull(points []point) []point {
 n := len(points)
 if n &lt; 3 {
 return nil
 }

 hull := make([]point, 0, n)
 start := 0

 // Find the leftmost point
 for i := 1; i &lt; n; i++ {
 if points[i].x &lt; points[start].x {
 start = i
 }
 }

 current := start
 next := -1

 for {
 hull = append(hull, points[current])

 // Find the next point on the hull
 for i := 0; i &lt; n; i++ {
 if i == current {
 continue
 }
 if next == -1 {
 next = i
 }
 cross := crossProduct(points[i], points[current], points[next])
 if cross &lt; 0 {
 next = i
 } else if cross == 0 {
 if distance(points[current], points[i]) &gt; distance(points[current], points[next]) {
 next = i
 }
 }
 }

 current = next
 next = -1

 if current == start {
 break
 }
 }

 return hull
}

func crossProduct(a, b, c point) int {
 return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x)
}

func distance(a, b point) int {
 dx := a.x - b.x
 dy := a.y - b.y
 return dx*dx + dy*dy
}</code></pre>
<p>The <code>convexHull</code> function takes a slice of points as input
and returns a slice of points representing the convex hull of the input
points. If the number of input points is less than 3, then the function
returns nil, since a convex hull requires at least 3 points.</p>
<p>We start by finding the leftmost point in the set of input points,
which will be the starting point of our convex hull. We initialize an
empty slice to hold the points on the hull.</p>
<p>Then we start iterating over the points to find the next point on the
hull. For each point, we calculate the cross product between the current
point, the next point, and the point being considered. If the cross
product is negative, then the point being considered is counterclockwise
to the current and next points, so we update the next point to be the
point being considered. If the cross product is zero, then the point
being considered is collinear with the current and next points, so we
update the next point only if the distance between the current point and
the point being considered is greater than the distance between the
current point and the current next point.</p>
<p>Once we have found the next point on the hull, we add it to the hull
and update the current point to be the next point. We repeat this
process until we have returned to the starting point, at which point we
have completed the convex hull.</p>
<p>The <code>crossProduct</code> function takes three points as input
and returns the cross product of the vectors formed by the two line
segments connecting the points.</p>
<p>The <code>distance</code> function takes two points as input and
returns the squared</p>
<h2 id="chapter-10-string-algorithms-1">Chapter 10: String
Algorithms</h2>
<ol type="1">
<li>Write a function in Golang to implement the Knuth-Morris-Pratt
algorithm for string searching. Here’s the implementation of the
Knuth-Morris-Pratt (KMP) algorithm for string searching in Go:</li>
</ol>
<pre class="golang"><code>func KMPSearch(text, pattern string) int {
 n := len(text)
 m := len(pattern)

 if m == 0 {
 return 0
 }

 if m &gt; n {
 return -1
 }

 // Calculate the prefix function
 prefix := make([]int, m)
 prefix[0] = 0
 j := 0
 for i := 1; i &lt; m; i++ {
 for j &gt; 0 &amp;&amp; pattern[j] != pattern[i] {
 j = prefix[j-1]
 }
 if pattern[j] == pattern[i] {
 j++
 }
 prefix[i] = j
 }

 // Use the prefix function to search for the pattern in the text
 j = 0
 for i := 0; i &lt; n; i++ {
 for j &gt; 0 &amp;&amp; pattern[j] != text[i] {
 j = prefix[j-1]
 }
 if pattern[j] == text[i] {
 j++
 }
 if j == m {
 return i - m + 1
 }
 }

 return -1
}</code></pre>
<p>The <code>KMPSearch</code> function takes two strings as input - the
text in which to search for the pattern and the pattern to search for -
and returns the index of the first occurrence of the pattern in the
text, or -1 if the pattern is not found.</p>
<p>The KMP algorithm uses a prefix function to avoid unnecessary
backtracking while searching for the pattern. The prefix function is
calculated as follows: for each position in the pattern, the length of
the longest proper suffix that is also a prefix of the substring up to
that position is computed. The prefix function is stored in an array
<code>prefix</code> of length <code>m</code> (the length of the
pattern).</p>
<p>To search for the pattern in the text, we initialize two indices
<code>i</code> and <code>j</code> to zero. We iterate over the
characters of the text. If the current character matches the current
character of the pattern, we increment <code>j</code>. If <code>j</code>
reaches the end of the pattern, we have found a match, so we return the
index <code>i - m + 1</code> of the start of the match in the text. If
the current character of the text does not match the current character
of the pattern, we use the prefix function to determine how far back to
backtrack <code>j</code>. We set <code>j</code> to the value of
<code>prefix[j-1]</code> (the length of the longest proper suffix of the
substring up to the previous position that is also a prefix of the
pattern). We continue until we reach the end of the text or find a
match.</p>
<p>Note that the implementation assumes that the input strings are ASCII
strings. If the input strings contain Unicode characters, the
implementation will need to be modified to handle multi-byte
characters.</p>
<ol start="2" type="1">
<li>Write a function in Golang to implement the Boyer-Moore algorithm
for string searching.</li>
</ol>
<pre class="golang"><code>func BoyerMooreSearch(text, pattern string) int {
 n := len(text)
 m := len(pattern)

 if m == 0 {
 return 0
 }

 if m &gt; n {
 return -1
 }

 // Preprocess the pattern
 lastOccurrence := make(map[byte]int)
 for i := 0; i &lt; m; i++ {
 lastOccurrence[pattern[i]] = i
 }

 // Search for the pattern in the text
 i := m - 1
 j := m - 1
 for i &lt; n &amp;&amp; j &gt;= 0 {
 if text[i] == pattern[j] {
 i--
 j--
 } else {
 if last, ok := lastOccurrence[text[i]]; ok &amp;&amp; last &lt; j {
 i = i + m - 1 - last
 j = m - 1
 } else {
 i = i + m
 j = m - 1
 }
 }
 }

 if j &lt; 0 {
 return i + 1
 } else {
 return -1
 }
}</code></pre>
<p>The <code>BoyerMooreSearch</code> function takes two strings as input
- the text in which to search for the pattern and the pattern to search
for - and returns the index of the first occurrence of the pattern in
the text, or -1 if the pattern is not found.</p>
<p>The Boyer-Moore algorithm uses two heuristic rules to avoid
unnecessary comparisons while searching for the pattern. The first rule
is the “bad character rule”, which states that if a character in the
text does not match the corresponding character in the pattern, we can
skip ahead in the text to the next occurrence of that character in the
pattern. To implement this rule, we preprocess the pattern to store the
index of the last occurrence of each character in the pattern in a hash
table <code>lastOccurrence</code>.</p>
<p>The second rule is the “good suffix rule”, which states that if a
suffix of the pattern matches a substring of the text, we can skip ahead
in the text to the next occurrence of the next longest suffix of the
pattern that matches a substring of the text. To implement this rule, we
keep track of two indices <code>i</code> and <code>j</code>. We start at
the end of the pattern (<code>i = m - 1</code>, <code>j = m - 1</code>)
and compare the characters of the pattern and text from right to left.
If the characters match, we decrement both indices. If they do not
match, we use the bad character rule to determine how far to skip ahead
in the text, and we update <code>i</code> and <code>j</code>
accordingly.</p>
<p>We continue until we reach the beginning of the text or find a match.
If we find a match, we return the index of the start of the match in the
text (<code>i + 1</code>). If we reach the beginning of the text without
finding a match, we return -1.</p>
<p>Note that this implementation assumes that the input strings are
ASCII strings. If the input strings contain Unicode characters, the
implementation will need to be modified to handle multi-byte
characters.</p>
<ol start="3" type="1">
<li>Write a function in Golang to implement the Rabin-Karp algorithm for
string matching.</li>
</ol>
<pre class="golang"><code>func RabinKarpSearch(text, pattern string) int {
 n := len(text)
 m := len(pattern)

 if m == 0 {
 return 0
 }

 if m &gt; n {
 return -1
 }

 // Compute the hash of the pattern
 patternHash := hash(pattern)

 // Search for the pattern in the text
 textHash := hash(text[:m])
 for i := 0; i &lt;= n-m; i++ {
 if textHash == patternHash &amp;&amp; text[i:i+m] == pattern {
 return i
 }
 if i &lt; n-m {
 textHash = rehash(text, i, i+m, textHash, m)
 }
 }

 return -1
}

// Computes the hash of a string using the Rabin-Karp hash function
func hash(str string) uint64 {
 var h uint64
 for i := 0; i &lt; len(str); i++ {
 h = (h &lt;&lt; 1) + uint64(str[i])
 }
 return h
}

// Computes the hash of a string segment by subtracting the contribution
// of the leftmost character and adding the contribution of the rightmost
// character, using the Rabin-Karp hash function
func rehash(str string, oldIndex, newIndex int, oldHash uint64, patternLen int) uint64 {
 var newHash uint64
 newHash = oldHash - uint64(str[oldIndex])&lt;&lt;(patternLen-1)
 newHash = (newHash &lt;&lt; 1) + uint64(str[newIndex])
 return newHash
}</code></pre>
<p>The <code>RabinKarpSearch</code> function takes two strings as input
- the text in which to search for the pattern and the pattern to search
for - and returns the index of the first occurrence of the pattern in
the text, or -1 if the pattern is not found.</p>
<p>The Rabin-Karp algorithm uses a rolling hash function to efficiently
compute the hash value of each substring of the text. We compute the
hash of the pattern before searching and use it to compare with the hash
of each substring of the text. If the hash values match, we compare the
substrings to see if they are actually equal.</p>
<p>The rolling hash function used in this implementation is a simple
implementation of the Rabin-Karp hash function, which uses a polynomial
hash function to compute the hash value of a string. The hash function
is defined as:</p>
<pre class="golang"><code>hash(s) = s[0] * x^(n-1) + s[1] * x^(n-2) + ... + s[n-1] * x^0</code></pre>
<p>where <code>s</code> is the string, <code>n</code> is the length of
the string, and <code>x</code> is a constant chosen to be a large prime
number.</p>
<p>To compute the hash of each substring of the text, we use a rolling
hash function that subtracts the contribution of the leftmost character
of the current substring and adds the contribution of the rightmost
character of the next substring, as shown in the <code>rehash</code>
function.</p>
<p>Note that this implementation assumes that the input strings are
ASCII strings. If the input strings contain Unicode characters, the
implementation will need to be modified to handle multi-byte
characters.</p>
<ol start="4" type="1">
<li>Write a function in Golang to build a suffix tree for a given
string.</li>
</ol>
<pre class="golang"><code>type Node struct {
 Edges map[byte]*Edge
 Suffix *Node
 Start int
 End *int
}

type Edge struct {
 Start *int
 End *int
 Node *Node
}

func BuildSuffixTree(s string) *Node {
 n := len(s)
 root := &amp;Node{Edges: make(map[byte]*Edge)}

 // Build the tree one character at a time
 activeNode := root
 activeEdge := 0
 activeLength := 0
 remainder := 0
 lastNewNode := root
 for i := 0; i &lt; n; i++ {
 lastNewNode = nil
 remainder++
 for remainder &gt; 0 {
 if activeLength == 0 {
 activeEdge = i
 }
 edge, ok := activeNode.Edges[s[activeEdge]]
 if !ok {
 // Create a new leaf node and edge
 leaf := &amp;Node{Edges: make(map[byte]*Edge), Start: i}
 edge = &amp;Edge{Start: &amp;i, End: nil, Node: leaf}
 activeNode.Edges[s[activeEdge]] = edge
 addSuffixLink(lastNewNode, activeNode)
 lastNewNode = nil
 } else {
 // Walk down the edge as far as possible
 j := *edge.Start
 if activeLength &gt;= *edge.End-j {
 activeEdge += *edge.End - j
 activeLength -= *edge.End - j
 activeNode = edge.Node
 continue
 }
 if s[*edge.Start+activeLength] == s[i] {
 // The current suffix already exists in the tree
 activeLength++
 addSuffixLink(lastNewNode, activeNode)
 lastNewNode = nil
 break
 }
 // Split the edge and create a new leaf node
 splitEnd := *edge.Start + activeLength
 splitNode := &amp;Node{Edges: make(map[byte]*Edge), Start: *edge.Start, End: &amp;splitEnd}
 splitEdge := &amp;Edge{Start: edge.Start, End: &amp;splitEnd, Node: splitNode}
 activeNode.Edges[s[activeEdge]] = splitEdge
 leaf := &amp;Node{Edges: make(map[byte]*Edge), Start: i}
 leafEdge := &amp;Edge{Start: &amp;i, End: nil, Node: leaf}
 splitNode.Edges[s[i]] = leafEdge
 edge.Start = &amp;splitEnd
 edge.Node = splitNode
 addSuffixLink(lastNewNode, splitNode)
 lastNewNode = splitNode
 }
 remainder--
 if activeNode == root &amp;&amp; activeLength &gt; 0 {
 activeLength--
 activeEdge = i - remainder + 1
 } else {
 activeNode = activeNode.Suffix
 }
 }
 }

 return root
}

// Adds a suffix link from the last new internal node to the specified node
func addSuffixLink(lastNewNode, node *Node) {
 if lastNewNode != nil {
 lastNewNode.Suffix = node
 }
}</code></pre>
<p>The <code>BuildSuffixTree</code> function takes a string as input and
returns the root node of the suffix tree for the string.</p>
<p>The implementation uses Ukkonen’s algorithm to build the suffix tree
one character at a time. The algorithm maintains an active point that is
initially set to the root of the tree. For each character in the string,
the algorithm either adds</p>
<ol start="5" type="1">
<li>Write a function in Golang to find all occurrences of a pattern in a
given string using suffix tree algorithm.</li>
</ol>
<pre class="golang"><code>type Node struct {
 Edges map[byte]*Edge
 Suffix *Node
 Start int
 End *int
}

type Edge struct {
 Start *int
 End *int
 Node *Node
}

// Finds all occurrences of a pattern in a string using a suffix tree
func FindAllOccurrences(s, pattern string) []int {
 n := len(s)
 root := buildSuffixTree(s)

 // Walk down the tree to find the nodes corresponding to the pattern
 nodes := []*Node{root}
 for i := 0; i &lt; len(pattern); i++ {
 var nextNodes []*Node
 for _, node := range nodes {
 if edge, ok := node.Edges[pattern[i]]; ok {
 nextNodes = append(nextNodes, edge.Node)
 }
 }
 nodes = nextNodes
 }

 // Collect the positions of the pattern in the string
 var positions []int
 for _, node := range nodes {
 collectPositions(node, n-len(pattern), &amp;positions)
 }
 sort.Ints(positions)

 return positions
}

// Builds a suffix tree for the given string
func buildSuffixTree(s string) *Node {
 // Implementation omitted for brevity
}

// Recursively collects the positions of the leaves below the given node
func collectPositions(node *Node, offset int, positions *[]int) {
 if node.End != nil {
 *positions = append(*positions, *node.End-offset)
 }
 for _, edge := range node.Edges {
 collectPositions(edge.Node, offset, positions)
 }
}</code></pre>
<p>The <code>FindAllOccurrences</code> function takes two strings as
input, <code>s</code> and <code>pattern</code>, and returns a slice of
integers representing the positions in <code>s</code> where the pattern
occurs.</p>
<p>The implementation first builds a suffix tree for the string
<code>s</code> using the <code>buildSuffixTree</code> function (omitted
for brevity). Then it walks down the tree to find the nodes
corresponding to the pattern. Finally, it collects the positions of the
leaves below these nodes and returns them as a sorted slice of
integers.</p>
<p>Note that this implementation assumes that the pattern is non-empty
and that it occurs at least once in the string. It also assumes that the
string and the pattern consist only of ASCII characters.</p>
<ol start="6" type="1">
<li>Write a function in Golang to implement the Longest Common
Subsequence (LCS) problem using dynamic programming. Here’s an
implementation of the Longest Common Subsequence (LCS) problem using
dynamic programming in Go:</li>
</ol>
<pre class="golang"><code>// Finds the length of the longest common subsequence of two strings using dynamic programming
func LongestCommonSubsequenceLength(s1, s2 string) int {
 m, n := len(s1), len(s2)
 dp := make([][]int, m+1)
 for i := range dp {
 dp[i] = make([]int, n+1)
 }

 for i := 1; i &lt;= m; i++ {
 for j := 1; j &lt;= n; j++ {
 if s1[i-1] == s2[j-1] {
 dp[i][j] = dp[i-1][j-1] + 1
 } else {
 dp[i][j] = max(dp[i-1][j], dp[i][j-1])
 }
 }
 }

 return dp[m][n]
}

// Returns the maximum of two integers
func max(a, b int) int {
 if a &gt; b {
 return a
 }
 return b
}</code></pre>
<p>The <code>LongestCommonSubsequenceLength</code> function takes two
strings as input, <code>s1</code> and <code>s2</code>, and returns an
integer representing the length of their longest common subsequence.</p>
<p>The implementation uses a dynamic programming approach to compute the
length of the LCS. It creates a 2D slice <code>dp</code> of size
<code>(m+1) x (n+1)</code> where <code>m</code> and <code>n</code> are
the lengths of <code>s1</code> and <code>s2</code>, respectively. The
value <code>dp[i][j]</code> represents the length of the LCS of the
first <code>i</code> characters of <code>s1</code> and the first
<code>j</code> characters of <code>s2</code>.</p>
<p>The algorithm fills in the <code>dp</code> table row by row, starting
from the first row and column. For each cell <code>dp[i][j]</code>, if
the characters <code>s1[i-1]</code> and <code>s2[j-1]</code> are the
same, then the LCS of the first <code>i</code> characters of
<code>s1</code> and the first <code>j</code> characters of
<code>s2</code> is equal to the LCS of the first <code>i-1</code>
characters of <code>s1</code> and the first <code>j-1</code> characters
of <code>s2</code>, plus one. Otherwise, the LCS is equal to the maximum
of the LCS of the first <code>i-1</code> characters of <code>s1</code>
and the first <code>j</code> characters of <code>s2</code>, and the LCS
of the first <code>i</code> characters of <code>s1</code> and the first
<code>j-1</code> characters of <code>s2</code>.</p>
<p>Finally, the function returns <code>dp[m][n]</code>, which represents
the length of the LCS of the entire strings <code>s1</code> and
<code>s2</code>.</p>
<ol start="7" type="1">
<li>Write a function in Golang to implement the Longest Palindromic
Subsequence problem using dynamic programming.</li>
</ol>
<p>Here’s an implementation of the Longest Palindromic Subsequence (LPS)
problem using dynamic programming in Go:</p>
<pre class="golang"><code>// Finds the length of the longest palindromic subsequence of a string using dynamic programming
func LongestPalindromicSubsequenceLength(s string) int {
 n := len(s)
 dp := make([][]int, n)
 for i := range dp {
 dp[i] = make([]int, n)
 dp[i][i] = 1
 }

 for l := 2; l &lt;= n; l++ {
 for i := 0; i &lt;= n-l; i++ {
 j := i + l - 1
 if s[i] == s[j] {
 dp[i][j] = dp[i+1][j-1] + 2
 } else {
 dp[i][j] = max(dp[i+1][j], dp[i][j-1])
 }
 }
 }

 return dp[0][n-1]
}

// Returns the maximum of two integers
func max(a, b int) int {
 if a &gt; b {
 return a
 }
 return b
}</code></pre>
<p>The <code>LongestPalindromicSubsequenceLength</code> function takes a
string <code>s</code> as input and returns an integer representing the
length of the longest palindromic subsequence in <code>s</code>.</p>
<p>The implementation uses a dynamic programming approach to compute the
length of the LPS. It creates a 2D slice <code>dp</code> of size
<code>n x n</code>, where <code>n</code> is the length of the input
string <code>s</code>. The value <code>dp[i][j]</code> represents the
length of the LPS of the substring <code>s[i...j]</code>.</p>
<p>The algorithm fills in the <code>dp</code> table diagonally, starting
from the main diagonal. The base cases are when the length of the
substring is 1, in which case <code>dp[i][i]</code> is always 1. For
substrings of length 2 or greater, the algorithm iterates over all
possible substrings of length <code>l</code>, starting from 2 and going
up to <code>n</code>. For each substring <code>s[i...j]</code>, if
<code>s[i]</code> and <code>s[j]</code> are the same, then the LPS of
<code>s[i...j]</code> is equal to the LPS of <code>s[i+1...j-1]</code>,
plus 2. Otherwise, the LPS of <code>s[i...j]</code> is equal to the
maximum of the LPS of <code>s[i+1...j]</code> and the LPS of
<code>s[i...j-1]</code>.</p>
<p>Finally, the function returns <code>dp[0][n-1]</code>, which
represents the length of the LPS of the entire input string
<code>s</code>.</p>
<ol start="8" type="1">
<li>Write a function in Golang to implement the Longest Palindromic
Substring problem using dynamic programming.</li>
</ol>
<pre class="golang"><code>// Finds the longest palindromic substring of a string using dynamic programming
func LongestPalindromicSubstring(s string) string {
 n := len(s)
 dp := make([][]bool, n)
 for i := range dp {
 dp[i] = make([]bool, n)
 }

 start, maxLength := 0, 1

 // All substrings of length 1 are palindromes
 for i := 0; i &lt; n; i++ {
 dp[i][i] = true
 }

 // Check for substrings of length 2
 for i := 0; i &lt; n-1; i++ {
 if s[i] == s[i+1] {
 dp[i][i+1] = true
 start = i
 maxLength = 2
 }
 }

 // Check for substrings of length 3 or more
 for k := 3; k &lt;= n; k++ {
 for i := 0; i &lt; n-k+1; i++ {
 j := i + k - 1
 if dp[i+1][j-1] &amp;&amp; s[i] == s[j] {
 dp[i][j] = true
 if k &gt; maxLength {
 start = i
 maxLength = k
 }
 }
 }
 }

 return s[start : start+maxLength]
}</code></pre>
<p>The <code>LongestPalindromicSubstring</code> function takes a string
<code>s</code> as input and returns a string representing the longest
palindromic substring in <code>s</code>.</p>
<p>The implementation uses a dynamic programming approach to find the
LPS. It creates a 2D slice <code>dp</code> of size <code>n x n</code>,
where <code>n</code> is the length of the input string <code>s</code>.
The value <code>dp[i][j]</code> is true if the substring
<code>s[i...j]</code> is a palindrome, and false otherwise.</p>
<p>The algorithm first initializes all substrings of length 1 as
palindromes, and then checks for palindromes of length 2. For substrings
of length 3 or more, the algorithm checks if the substring
<code>s[i+1...j-1]</code> is a palindrome and if <code>s[i]</code> is
equal to <code>s[j]</code>. If so, the substring <code>s[i...j]</code>
is also a palindrome.</p>
<p>The algorithm keeps track of the starting index and length of the
longest palindromic substring seen so far, and returns this substring at
the end of the function.</p>
<p>Finally, the function returns the substring
<code>s[start : start+maxLength]</code>, which represents the longest
palindromic substring in the input string <code>s</code>.</p>
<ol start="9" type="1">
<li>Write a function in Golang to implement the Edit Distance problem
using dynamic programming. Here’s an implementation of the Edit Distance
problem using dynamic programming in Go:</li>
</ol>
<pre class="golang"><code>// Computes the minimum edit distance between two strings using dynamic programming
func EditDistance(s1, s2 string) int {
 m, n := len(s1), len(s2)
 dp := make([][]int, m+1)
 for i := range dp {
 dp[i] = make([]int, n+1)
 }

 // Base cases
 for i := 0; i &lt;= m; i++ {
 dp[i][0] = i
 }
 for j := 0; j &lt;= n; j++ {
 dp[0][j] = j
 }

 // Compute edit distance for substrings of s1 and s2
 for i := 1; i &lt;= m; i++ {
 for j := 1; j &lt;= n; j++ {
 if s1[i-1] == s2[j-1] {
 dp[i][j] = dp[i-1][j-1]
 } else {
 dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
 }
 }
 }

 return dp[m][n]
}

// Helper function to compute the minimum of three integers
func min(a, b, c int) int {
 if a &lt; b {
 if a &lt; c {
 return a
 } else {
 return c
 }
 } else {
 if b &lt; c {
 return b
 } else {
 return c
 }
 }
}</code></pre>
<p>The <code>EditDistance</code> function takes two strings
<code>s1</code> and <code>s2</code> as input and returns an integer
representing the minimum edit distance between <code>s1</code> and
<code>s2</code>.</p>
<p>The implementation uses a dynamic programming approach to compute the
edit distance. It creates a 2D slice <code>dp</code> of size
<code>(m+1) x (n+1)</code>, where <code>m</code> and <code>n</code> are
the lengths of <code>s1</code> and <code>s2</code>, respectively. The
value <code>dp[i][j]</code> represents the minimum edit distance between
the substrings <code>s1[0...i-1]</code> and
<code>s2[0...j-1]</code>.</p>
<p>The algorithm initializes the base cases: if one of the strings is
empty, the edit distance is the length of the other string. It then
computes the edit distance for substrings of <code>s1</code> and
<code>s2</code> using the following recurrence relation:</p>
<ul>
<li>If the characters at <code>s1[i-1]</code> and <code>s2[j-1]</code>
are the same, then the edit distance is the same as the edit distance
between the substrings <code>s1[0...i-2]</code> and
<code>s2[0...j-2]</code>.</li>
<li>Otherwise, the edit distance is 1 plus the minimum of the edit
distance between <code>s1[0...i-1]</code> and <code>s2[0...j-2]</code>
(deletion), <code>s1[0...i-2]</code> and <code>s2[0...j-1]</code>
(insertion), and <code>s1[0...i-2]</code> and <code>s2[0...j-2]</code>
(substitution).</li>
</ul>
<p>The algorithm returns the value <code>dp[m][n]</code>, which
represents the minimum edit distance between the input strings
<code>s1</code> and <code>s2</code>.</p>
<p>In addition, the implementation includes a helper function
<code>min</code> that computes the minimum of three integers.</p>
<ol start="10" type="1">
<li>Write a function in Golang to implement the Z algorithm for pattern
searching.</li>
</ol>
<p>Here’s an implementation of the Z algorithm for pattern searching in
Golang:</p>
<pre class="golang"><code>package main

import &quot;fmt&quot;

func calculateZArray(str string) []int {
 length := len(str)
 zArray := make([]int, length)
 zArray[0] = length
 
 left, right := 0, 0
 for i := 1; i &lt; length; i++ {
 if i &gt; right {
 left, right = i, i
 for right &lt; length &amp;&amp; str[right] == str[right-left] {
 right++
 }
 zArray[i] = right - left
 right--
 } else {
 k := i - left
 if zArray[k] &lt; right-i+1 {
 zArray[i] = zArray[k]
 } else {
 left = i
 for right &lt; length &amp;&amp; str[right] == str[right-left] {
 right++
 }
 zArray[i] = right - left
 right--
 }
 }
 }
 
 return zArray
}

func searchPattern(pattern, text string) []int {
 str := pattern + &quot;$&quot; + text
 length := len(str)
 zArray := calculateZArray(str)
 
 var result []int
 for i := 0; i &lt; length; i++ {
 if zArray[i] == len(pattern) {
 result = append(result, i-len(pattern)-1)
 }
 }
 
 return result
}

func main() {
 text := &quot;ABXABCABZABXABYABXABCABY&quot;
 pattern := &quot;AB&quot;
 result := searchPattern(pattern, text)
 fmt.Println(result)
}</code></pre>
<p>In this implementation, <code>calculateZArray</code> function
calculates the Z array for a given string. The
<code>searchPattern</code> function appends the positions of pattern
occurrences to a result slice and returns it. The main function
demonstrates how to use the <code>searchPattern</code> function.</p>
<h2 id="chapter-11-tree-algorithms-1">Chapter 11: Tree Algorithms</h2>
<ol type="1">
<li>Implement a binary search tree in Golang and perform pre-order,
in-order, and post-order traversals. Here’s an implementation of a
binary search tree in Golang that includes pre-order, in-order, and
post-order traversal methods:</li>
</ol>
<pre class="golang"><code>package main

import &quot;fmt&quot;

type Node struct {
 Value int
 Left *Node
 Right *Node
}

type BinarySearchTree struct {
 Root *Node
}

func (bst *BinarySearchTree) Insert(value int) {
 newNode := &amp;Node{Value: value}
 if bst.Root == nil {
 bst.Root = newNode
 } else {
 current := bst.Root
 for {
 if value &lt; current.Value {
 if current.Left == nil {
 current.Left = newNode
 break
 } else {
 current = current.Left
 }
 } else {
 if current.Right == nil {
 current.Right = newNode
 break
 } else {
 current = current.Right
 }
 }
 }
 }
}

func (bst *BinarySearchTree) PreOrderTraversal(node *Node) {
 if node == nil {
 return
 }
 fmt.Printf(&quot;%d &quot;, node.Value)
 bst.PreOrderTraversal(node.Left)
 bst.PreOrderTraversal(node.Right)
}

func (bst *BinarySearchTree) InOrderTraversal(node *Node) {
 if node == nil {
 return
 }
 bst.InOrderTraversal(node.Left)
 fmt.Printf(&quot;%d &quot;, node.Value)
 bst.InOrderTraversal(node.Right)
}

func (bst *BinarySearchTree) PostOrderTraversal(node *Node) {
 if node == nil {
 return
 }
 bst.PostOrderTraversal(node.Left)
 bst.PostOrderTraversal(node.Right)
 fmt.Printf(&quot;%d &quot;, node.Value)
}

func main() {
 bst := &amp;BinarySearchTree{}
 bst.Insert(50)
 bst.Insert(30)
 bst.Insert(70)
 bst.Insert(20)
 bst.Insert(40)
 bst.Insert(60)
 bst.Insert(80)
 fmt.Println(&quot;Pre-order traversal:&quot;)
 bst.PreOrderTraversal(bst.Root)
 fmt.Println(&quot;\nIn-order traversal:&quot;)
 bst.InOrderTraversal(bst.Root)
 fmt.Println(&quot;\nPost-order traversal:&quot;)
 bst.PostOrderTraversal(bst.Root)
}</code></pre>
<p>In this implementation, <code>Node</code> represents a single node in
the binary search tree, and <code>BinarySearchTree</code> represents the
tree itself. The <code>Insert</code> method adds a new node to the tree
at the appropriate location according to its value.</p>
<p>The <code>PreOrderTraversal</code>, <code>InOrderTraversal</code>,
and <code>PostOrderTraversal</code> methods perform the respective
traversals on the tree, starting from the given node. In the
<code>main</code> function, we create a binary search tree, insert some
values into it, and then print out the results of the three different
traversal methods.</p>
<ol start="2" type="1">
<li>Here’s an implementation of an AVL tree in Golang that demonstrates
its self-balancing properties by inserting and deleting nodes:</li>
</ol>
<pre class="golang"><code>package main

import &quot;fmt&quot;

type Node struct {
 Value int
 Height int
 Left *Node
 Right *Node
}

type AVLTree struct {
 Root *Node
}

func (tree *AVLTree) Insert(value int) {
 newNode := &amp;Node{Value: value, Height: 1}
 if tree.Root == nil {
 tree.Root = newNode
 return
 }
 tree.Root = tree.Root.insert(newNode)
}

func (node *Node) insert(newNode *Node) *Node {
 if newNode.Value &lt; node.Value {
 if node.Left == nil {
 node.Left = newNode
 } else {
 node.Left = node.Left.insert(newNode)
 }
 } else {
 if node.Right == nil {
 node.Right = newNode
 } else {
 node.Right = node.Right.insert(newNode)
 }
 }
 node = node.balance()
 return node
}

func (node *Node) balance() *Node {
 leftHeight := node.height(node.Left)
 rightHeight := node.height(node.Right)
 if leftHeight-rightHeight &gt; 1 {
 if node.Left.balanceFactor() &lt; 0 {
 node.Left = node.Left.rotateLeft()
 }
 node = node.rotateRight()
 } else if rightHeight-leftHeight &gt; 1 {
 if node.Right.balanceFactor() &gt; 0 {
 node.Right = node.Right.rotateRight()
 }
 node = node.rotateLeft()
 }
 node.Height = 1 + node.heightMax(node.Left, node.Right)
 return node
}

func (node *Node) rotateRight() *Node {
 newRoot := node.Left
 node.Left = newRoot.Right
 newRoot.Right = node
 node.Height = 1 + node.heightMax(node.Left, node.Right)
 newRoot.Height = 1 + node.heightMax(newRoot.Left, newRoot.Right)
 return newRoot
}

func (node *Node) rotateLeft() *Node {
 newRoot := node.Right
 node.Right = newRoot.Left
 newRoot.Left = node
 node.Height = 1 + node.heightMax(node.Left, node.Right)
 newRoot.Height = 1 + node.heightMax(newRoot.Left, newRoot.Right)
 return newRoot
}

func (node *Node) height(n *Node) int {
 if n == nil {
 return 0
 }
 return n.Height
}

func (node *Node) heightMax(left, right *Node) int {
 if node.height(left) &gt; node.height(right) {
 return node.height(left)
 }
 return node.height(right)
}

func (node *Node) balanceFactor() int {
 return node.height(node.Left) - node.height(node.Right)
}

func (tree *AVLTree) Delete(value int) {
 if tree.Root == nil {
 return
 }
 tree.Root = tree.Root.delete(value)
}

func (node *Node) delete(value int) *Node {
 if value &lt; node.Value {
 node.Left = node.Left.delete(value)
 } else if value &gt; node.Value {
 node.Right = node.Right.delete(value)
 } else {
 if node.Left == nil {
 return node.Right
 } else if node.Right == nil {
 return node.Left
 } else {
 minNode := node.Right.min()
 node.Value = minNode.Value
 node.Right = node.Right.delete(minNode.Value)
 }
 }
 node = node.balance()
 return node</code></pre>
<ol start="3" type="1">
<li>here’s an implementation of a red-black tree in Golang. We’ll start
by defining the <code>Node</code> struct:</li>
</ol>
<pre class="golang"><code>type color bool

const (
 black color = false
 red color = true
)

type Node struct {
 key int
 value interface{}
 color color
 left, right *Node
}</code></pre>
<p>Next, we’ll define the <code>RedBlackTree</code> struct and the
functions associated with it:</p>
<pre class="golang"><code>type RedBlackTree struct {
 root *Node
}

func NewRedBlackTree() *RedBlackTree {
 return &amp;RedBlackTree{}
}

func (t \*RedBlackTree) Insert(key int, value interface{}) {
 t.root = t.insert(t.root, key, value)
 t.root.color = black
}

func (t \*RedBlackTree) Delete(key int) {
 if t.root == nil {
 return
 }

 t.root = t.delete(t.root, key)
 if t.root != nil {
 t.root.color = black
 }
}

func (t \*RedBlackTree) insert(n *Node, key int, value interface{}) *Node {
 if n == nil {
 return &amp;Node{key: key, value: value, color: red}
 }

 if key &lt; n.key {
 n.left = t.insert(n.left, key, value)
 } else if key &gt; n.key {
 n.right = t.insert(n.right, key, value)
 } else {
 n.value = value
 }

 if isRed(n.right) &amp;&amp; !isRed(n.left) {
 n = rotateLeft(n)
 }
 if isRed(n.left) &amp;&amp; isRed(n.left.left) {
 n = rotateRight(n)
 }
 if isRed(n.left) &amp;&amp; isRed(n.right) {
 flipColors(n)
 }

 return n
}

func (t \*RedBlackTree) delete(n *Node, key int) *Node {
 if key &lt; n.key {
 if n.left == nil {
 return n
 }
 if !isRed(n.left) &amp;&amp; !isRed(n.left.left) {
 n = moveRedLeft(n)
 }
 n.left = t.delete(n.left, key)
 } else {
 if isRed(n.left) {
 n = rotateRight(n)
 }
 if key == n.key &amp;&amp; n.right == nil {
 return nil
 }
 if n.right != nil {
 if !isRed(n.right) &amp;&amp; !isRed(n.right.left) {
 n = moveRedRight(n)
 }
 if key == n.key {
 min := findMin(n.right)
 n.key = min.key
 n.value = min.value
 n.right = deleteMin(n.right)
 } else {
 n.right = t.delete(n.right, key)
 }
 }
 }
 return balance(n)
}

func isRed(n \*Node) bool {
 if n == nil {
 return false
 }
 return n.color == red
}

func rotateLeft(n \*Node) *Node {
 x := n.right
 n.right = x.left
 x.left = n
 x.color = n.color
 n.color = red
 return x
}

func rotateRight(n \*Node) *Node {
 x := n.left
 n.left = x.right
 x.right = n
 x.color = n.color
 n.color = red
 return x
}

func flipColors(n \*Node) {
 n.color = !n.color
 n.left.color = !n.left.color
 n.right.color = !n</code></pre>
<p>Sure, here’s a possible implementation of a function to check whether
a binary tree is a binary search tree:</p>
<pre class="golang"><code>type Node struct {
 Value int
 Left *Node
 Right *Node
}

func isBST(root \*Node) bool {
 return isBSTHelper(root, nil, nil)
}

func isBSTHelper(node \*Node, min \*int, max \*int) bool {
 if node == nil {
 return true
 }
 if (min != nil &amp;&amp; node.Value &lt;= *min) || (max != nil &amp;&amp; node.Value &gt;= *max) {
 return false
 }
 return isBSTHelper(node.Left, min, &amp;node.Value) &amp;&amp; isBSTHelper(node.Right, &amp;node.Value, max)
}</code></pre>
<p>The <code>isBST</code> function takes a <code>Node</code> pointer,
which is the root of the binary tree, and returns a boolean indicating
whether the tree is a binary search tree or not. It calls a helper
function <code>isBSTHelper</code> with additional arguments
<code>min</code> and <code>max</code>, which represent the minimum and
maximum values that the current node’s value can take.</p>
<p>The <code>isBSTHelper</code> function recursively checks if the
current node is a valid BST node, by ensuring that its value is within
the range defined by <code>min</code> and <code>max</code>, and then
calls itself on the left and right subtrees with updated
<code>min</code> and <code>max</code> values.</p>
<p>Note that this implementation assumes that the binary tree contains
distinct values. If the binary tree can contain duplicates, you would
need to modify the comparison operators to account for that.</p>
<p>Certainly! Here’s a possible implementation of a function to find the
maximum value in a binary tree:</p>
<pre class="golang"><code>type Node struct {
 Value int
 Left *Node
 Right *Node
}

func maxNodeValue(root \*Node) int {
 if root == nil {
 return -1 // or any other default value that makes sense for your use case
 }
 max := root.Value
 if leftMax := maxNodeValue(root.Left); leftMax &gt; max {
 max = leftMax
 }
 if rightMax := maxNodeValue(root.Right); rightMax &gt; max {
 max = rightMax
 }
 return max
}</code></pre>
<p>The <code>maxNodeValue</code> function takes a <code>Node</code>
pointer, which is the root of the binary tree, and returns the maximum
value in the tree as an integer. It recursively checks the maximum value
of the current node, its left subtree and its right subtree, and returns
the maximum of the three.</p>
<p>Note that this implementation assumes that all the values in the
binary tree are non-negative. If the binary tree can contain negative
values, you would need to modify the default value returned when the
root is <code>nil</code>.</p>
<p>Certainly! Here’s a possible implementation of a function to find the
kth smallest element in a binary search tree:</p>
<pre class="golang"><code>type Node struct {
 Value int
 Left *Node
 Right *Node
}

func kthSmallest(root \*Node, k int) int {
 if root == nil {
 return -1 // or any other default value that makes sense for your use case
 }
 stack := []*Node{}
 curr := root
 count := 0
 for curr != nil || len(stack) &gt; 0 {
 for curr != nil {
 stack = append(stack, curr)
 curr = curr.Left
 }
 curr = stack[len(stack)-1]
 stack = stack[:len(stack)-1]
 count++
 if count == k {
 return curr.Value
 }
 curr = curr.Right
 }
 return -1 // or any other default value that makes sense for your use case
}</code></pre>
<p>The <code>kthSmallest</code> function takes a <code>Node</code>
pointer, which is the root of the binary search tree, and an integer
<code>k</code>, and returns the value of the kth smallest element in the
tree. It uses a stack-based iterative inorder traversal to visit the
nodes in ascending order, and stops when it has visited <code>k</code>
nodes.</p>
<p>Note that this implementation assumes that the binary search tree
contains at least <code>k</code> nodes. If the tree can contain fewer
nodes than <code>k</code>, you would need to modify the default value
returned when the kth smallest element is not found.</p>
<p>Sure! Here’s a possible implementation of a function to find the
lowest common ancestor of two nodes in a binary tree:</p>
<pre class="golang"><code>type Node struct {
 Value int
 Left *Node
 Right *Node
}

func lowestCommonAncestor(root, p, q \*Node) *Node {
 if root == nil {
 return nil
 }
 if root == p || root == q {
 return root
 }
 leftLCA := lowestCommonAncestor(root.Left, p, q)
 rightLCA := lowestCommonAncestor(root.Right, p, q)
 if leftLCA != nil &amp;&amp; rightLCA != nil {
 return root
 }
 if leftLCA != nil {
 return leftLCA
 }
 return rightLCA
}</code></pre>
<p>The <code>lowestCommonAncestor</code> function takes a
<code>Node</code> pointer, which is the root of the binary tree, and two
<code>Node</code> pointers <code>p</code> and <code>q</code>, which are
the nodes whose lowest common ancestor we want to find. It recursively
checks if <code>p</code> and <code>q</code> are descendants of the
current node’s left subtree, right subtree or are equal to the current
node. If <code>p</code> and <code>q</code> are in different subtrees,
then the current node is their lowest common ancestor. If they are both
in the left subtree, the function recursively checks the left subtree.
If they are both in the right subtree, the function recursively checks
the right subtree.</p>
<p>Note that this implementation assumes that both <code>p</code> and
<code>q</code> are present in the binary tree. If either <code>p</code>
or <code>q</code> is not present, you would need to modify the code to
handle that case.</p>
<p>Certainly! Here’s a possible implementation of a function to find the
diameter of a binary tree:</p>
<pre class="golang"><code>type Node struct {
 Value int
 Left *Node
 Right *Node
}

func diameter(root \*Node) int {
 if root == nil {
 return 0
 }
 leftHeight := height(root.Left)
 rightHeight := height(root.Right)
 leftDiameter := diameter(root.Left)
 rightDiameter := diameter(root.Right)
 return max(leftHeight+rightHeight+1, max(leftDiameter, rightDiameter))
}

func height(node \*Node) int {
 if node == nil {
 return 0
 }
 return 1 + max(height(node.Left), height(node.Right))
}

func max(a, b int) int {
 if a &gt; b {
 return a
 }
 return b
}</code></pre>
<p>The <code>diameter</code> function takes a <code>Node</code> pointer,
which is the root of the binary tree, and returns the diameter of the
tree as an integer. It recursively calculates the diameter of the tree
by computing the height of the left subtree, the height of the right
subtree, and the diameters of the left and right subtrees. The maximum
of these values is the diameter of the tree. Note that the diameter of
the tree is the maximum of:</p>
<ul>
<li>the diameter of the left subtree</li>
<li>the diameter of the right subtree</li>
<li>the height of the left subtree + the height of the right subtree +
1</li>
</ul>
<p>The <code>height</code> function is a helper function that takes a
<code>Node</code> pointer and returns the height of the subtree rooted
at that node.</p>
<p>Note that this implementation has a time complexity of O(n^2) in the
worst case, where n is the number of nodes in the tree, because it
re-computes the height of the left and right subtrees for each node in
the tree. There are more efficient algorithms to compute the diameter of
a binary tree that have a time complexity of O(n), but they are more
complex.</p>
<p>Sure! Here’s a possible implementation of a function to check whether
a binary tree is balanced:</p>
<pre class="golang"><code>type Node struct {
 Value int
 Left *Node
 Right *Node
}

func isBalanced(root \*Node) bool {
 if root == nil {
 return true
 }
 leftHeight := height(root.Left)
 rightHeight := height(root.Right)
 if abs(leftHeight-rightHeight) &gt; 1 {
 return false
 }
 return isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)
}

func height(node \*Node) int {
 if node == nil {
 return 0
 }
 return 1 + max(height(node.Left), height(node.Right))
}

func max(a, b int) int {
 if a &gt; b {
 return a
 }
 return b
}

func abs(a int) int {
 if a &lt; 0 {
 return -a
 }
 return a
}</code></pre>
<p>The <code>isBalanced</code> function takes a <code>Node</code>
pointer, which is the root of the binary tree, and returns a boolean
value that indicates whether the tree is balanced or not. It recursively
checks whether the left and right subtrees of each node are balanced,
and whether the difference between the heights of the left and right
subtrees is no greater than one. The <code>height</code> function is a
helper function that takes a <code>Node</code> pointer and returns the
height of the subtree rooted at that node.</p>
<p>Note that this implementation has a time complexity of O(n^2) in the
worst case, where n is the number of nodes in the tree, because it
re-computes the height of the left and right subtrees for each node in
the tree. There are more efficient algorithms to check the balance of a
binary tree that have a time complexity of O(n), but they are more
complex.</p>
<p>Sure! Here’s a possible implementation of a function to flatten a
binary tree into a linked list:</p>
<pre class="golang"><code>type Node struct {
 Value int
 Left *Node
 Right *Node
}

func flatten(root \*Node) {
 if root == nil {
 return
 }
 flatten(root.Left)
 flatten(root.Right)
 if root.Left != nil {
 tmp := root.Right
 root.Right = root.Left
 root.Left = nil
 for root.Right != nil {
 root = root.Right
 }
 root.Right = tmp
 }
}</code></pre>
<p>The <code>flatten</code> function takes a <code>Node</code> pointer,
which is the root of the binary tree, and modifies the tree in-place to
flatten it into a linked list. It recursively flattens the left and
right subtrees of each node, and then attaches the left subtree (if it
exists) to the right of the current node, and makes the left child of
the current node nil. The last node in the flattened subtree is then
found, and its right child is set to the right subtree (if it exists).
The process continues recursively until the entire tree is flattened
into a linked list.</p>
<p>Note that the time complexity of this implementation is O(n), where n
is the number of nodes in the tree, since it visits each node in the
tree once.</p>
<h2 id="chapter-12-hashing-algorithms-1">Chapter 12: Hashing
Algorithms</h2>
<p>Here’s a possible implementation of a hash table that supports the
<code>insert</code>, <code>get</code>, and <code>delete</code>
operations:</p>
<pre class="golang"><code>type Node struct {
 Key string
 Value interface{}
 Next *Node
}

type HashTable struct {
 size int
 capacity int
 buckets []*Node
}

func NewHashTable(capacity int) *HashTable {
 return &amp;HashTable{
 size: 0,
 capacity: capacity,
 buckets: make([]*Node, capacity),
 }
}

func (h \*HashTable) Insert(key string, value interface{}) {
 index := h.hash(key)
 node := h.buckets[index]
 for node != nil {
 if node.Key == key {
 node.Value = value
 return
 }
 node = node.Next
 }
 newNode := &amp;Node{
 Key: key,
 Value: value,
 Next: h.buckets[index],
 }
 h.buckets[index] = newNode
 h.size++
}

func (h \*HashTable) Get(key string) interface{} {
 index := h.hash(key)
 node := h.buckets[index]
 for node != nil {
 if node.Key == key {
 return node.Value
 }
 node = node.Next
 }
 return nil
}

func (h \*HashTable) Delete(key string) {
 index := h.hash(key)
 node := h.buckets[index]
 var prev *Node
 for node != nil {
 if node.Key == key {
 if prev == nil {
 h.buckets[index] = node.Next
 } else {
 prev.Next = node.Next
 }
 h.size--
 return
 }
 prev = node
 node = node.Next
 }
}

func (h \*HashTable) hash(key string) int {
 hash := 0
 for i := 0; i &lt; len(key); i++ {
 hash = (31*hash + int(key[i])) % h.capacity
 }
 return hash
}</code></pre>
<p>The <code>HashTable</code> struct has a <code>size</code> field to
keep track of the number of elements in the hash table, a
<code>capacity</code> field to specify the number of buckets in the hash
table, and a <code>buckets</code> field which is an array of linked
lists. The <code>Insert</code> method takes a <code>key</code> and a
<code>value</code>, computes the hash of the <code>key</code>, and adds
a new <code>Node</code> to the appropriate bucket of the hash table. If
a <code>Node</code> with the same <code>key</code> already exists in the
bucket, its <code>value</code> is updated instead. The <code>Get</code>
method takes a <code>key</code>, computes the hash of the
<code>key</code>, and returns the <code>value</code> associated with the
<code>key</code> if it exists in the hash table, or <code>nil</code>
otherwise. The <code>Delete</code> method takes a <code>key</code>,
computes the hash of the <code>key</code>, and removes the
<code>Node</code> with the specified <code>key</code> from the
appropriate bucket of the hash table. If no <code>Node</code> with the
<code>key</code> is found, the method does nothing.</p>
<p>Note that this implementation uses separate chaining to handle
collisions between hash values, i.e., when multiple keys map to the same
bucket in the hash table. Each bucket is represented as a linked list of
<code>Node</code>s, where each <code>Node</code> contains a
<code>key</code>, a <code>value</code>, and a reference to the next
<code>Node</code> in the list. The <code>hash</code> function uses the
djb2 hash algorithm to compute the hash value of a string key.</p>
<p>Sure! Here’s a possible implementation of a function that finds the
first non-repeated integer in an array of integers using a hash
table:</p>
<pre class="golang"><code>func FirstNonRepeatedInteger(arr []int) int {
 counts := make(map[int]int)
 for _, x := range arr {
 counts[x]++
 }
 for _, x := range arr {
 if counts[x] == 1 {
 return x
 }
 }
 return -1 // if all integers are repeated
}</code></pre>
<p>The <code>FirstNonRepeatedInteger</code> function takes an array of
integers as input and returns the first non-repeated integer in the
array. It uses a hash table (implemented as a <code>map[int]int</code>)
to count the number of occurrences of each integer in the array. The
first loop iterates over the array and updates the counts in the hash
table. The second loop iterates over the array again and returns the
first integer with a count of 1, i.e., the first non-repeated integer.
If all integers are repeated, the function returns -1.</p>
<p>Note that this implementation has a time complexity of O(n) and a
space complexity of O(n), where n is the length of the input array. The
space complexity is due to the hash table used to store the counts of
each integer.</p>
<p>Sure! Here’s a possible implementation of a function that finds the
longest substring without repeating characters in a string using a hash
table:</p>
<pre class="golang"><code>func LongestSubstringWithoutRepeatingChars(s string) string {
 var result string
 charMap := make(map[rune]int)
 start := 0
 for end, char := range s {
 if prev, found := charMap[char]; found &amp;&amp; prev &gt;= start {
 start = prev + 1
 }
 charMap[char] = end
 curr := s[start : end+1]
 if len(curr) &gt; len(result) {
 result = curr
 }
 }
 return result
}</code></pre>
<p>The <code>LongestSubstringWithoutRepeatingChars</code> function takes
a string as input and returns the longest substring without repeating
characters in the string. It uses a hash table (implemented as a
<code>map[rune]int</code>) to keep track of the most recent position of
each character in the substring being examined. The function also
maintains two pointers, <code>start</code> and <code>end</code>, which
mark the beginning and end of the current substring being examined.</p>
<p>The function iterates over the string, adding each character to the
hash table and updating the <code>start</code> pointer if the character
is already present in the substring being examined. If a new longest
substring is found, the function updates the <code>result</code>
variable accordingly. Finally, the function returns the
<code>result</code> variable.</p>
<p>Note that this implementation has a time complexity of O(n), where n
is the length of the input string. The space complexity is also O(n),
due to the hash table used to store the most recent position of each
character.</p>
<p>Sure! Here’s a possible implementation of a hash table using linear
probing as the collision resolution technique:</p>
<pre class="golang"><code>type HashTable struct {
 capacity int
 size int
 keys []string
 values []int
}

func NewHashTable(capacity int) *HashTable {
 return &amp;HashTable{
 capacity: capacity,
 size: 0,
 keys: make([]string, capacity),
 values: make([]int, capacity),
 }
}

func (ht \*HashTable) hash(key string) int {
 hash := 0
 for _, char := range key {
 hash = (hash*31 + int(char)) % ht.capacity
 }
 return hash
}

func (ht \*HashTable) Insert(key string, value int) {
 if ht.size == ht.capacity {
 panic(&quot;hash table full&quot;)
 }
 hash := ht.hash(key)
 for ht.keys[hash] != &quot;&quot; &amp;&amp; ht.keys[hash] != key {
 hash = (hash + 1) % ht.capacity
 }
 ht.keys[hash] = key
 ht.values[hash] = value
 ht.size++
}

func (ht \*HashTable) Get(key string) (int, bool) {
 hash := ht.hash(key)
 for ht.keys[hash] != &quot;&quot; {
 if ht.keys[hash] == key {
 return ht.values[hash], true
 }
 hash = (hash + 1) % ht.capacity
 }
 return 0, false
}

func (ht \*HashTable) Delete(key string) bool {
 hash := ht.hash(key)
 for ht.keys[hash] != &quot;&quot; {
 if ht.keys[hash] == key {
 ht.keys[hash] = &quot;&quot;
 ht.values[hash] = 0
 ht.size--
 return true
 }
 hash = (hash + 1) % ht.capacity
 }
 return false
}</code></pre>
<p>The <code>HashTable</code> struct represents a hash table using
linear probing as the collision resolution technique. The
<code>NewHashTable</code> function creates a new hash table with the
specified capacity.</p>
<p>The <code>hash</code> function takes a key and returns its hash code
using the polynomial hash function with a prime base of 31.</p>
<p>The <code>Insert</code> function inserts a key-value pair into the
hash table using linear probing to resolve collisions. If the hash table
is full, the function panics.</p>
<p>The <code>Get</code> function retrieves the value associated with a
given key from the hash table. If the key is not found in the hash
table, the function returns false.</p>
<p>The <code>Delete</code> function removes a key-value pair from the
hash table. If the key is not found in the hash table, the function
returns false.</p>
<p>Note that this implementation has a worst-case time complexity of
O(n), where n is the number of elements in the hash table. This worst
case occurs when all keys hash to the same value and all of them are
clustered in a single chain in the hash table. In practice, however,
this worst case is rare, and linear probing can provide good performance
for hash tables with low load factors.</p>
<p>Sure, here’s a possible implementation of a function that takes in
two strings and determines whether they are anagrams of each other using
a hash table:</p>
<pre class="golang"><code>func areAnagrams(s1, s2 string) bool {
 if len(s1) != len(s2) {
 return false
 }

 // create a map to count the occurrences of each character in s1
 counts := make(map[rune]int)
 for _, ch := range s1 {
 counts[ch]++
 }

 // decrement the count for each character in s2, and check if all counts become zero
 for _, ch := range s2 {
 if counts[ch] == 0 {
 return false
 }
 counts[ch]--
 }

 // if all counts are zero, then s1 and s2 are anagrams
 return true
}</code></pre>
<p>The <code>areAnagrams</code> function takes two strings
<code>s1</code> and <code>s2</code> as input and returns true if they
are anagrams of each other, and false otherwise.</p>
<p>First, the function checks if the lengths of the two strings are
equal. If not, then they cannot be anagrams, and the function returns
false.</p>
<p>Next, the function creates a map called <code>counts</code> that will
be used to count the occurrences of each character in <code>s1</code>.
The <code>counts</code> map is initialized with zero counts for all
characters in <code>s1</code>, using a loop that iterates over the runes
in <code>s1</code>.</p>
<p>After that, the function decrements the count for each character in
<code>s2</code> and checks if any count becomes negative or zero. If the
count of a character becomes zero, then that character is present the
same number of times in both <code>s1</code> and <code>s2</code>. If the
count becomes negative, then <code>s2</code> contains a character that
is not present in <code>s1</code>, and the function returns false.</p>
<p>Finally, the function checks if all counts in the <code>counts</code>
map are zero. If they are, then <code>s1</code> and <code>s2</code> are
anagrams, and the function returns true. Otherwise, the function returns
false.</p>
<p>Sure, here’s a possible implementation of a function that takes in a
list of words and groups them by their anagrams using a hash table:</p>
<pre class="golang"><code>func groupAnagrams(words []string) [][]string {
 groups := make(map[string][]string)

 for _, word := range words {
 // sort the characters of the word to get its canonical form
 sorted := sortString(word)

 // add the word to the group for its canonical form
 groups[sorted] = append(groups[sorted], word)
 }

 // convert the map of groups to a slice of slices
 var result [][]string
 for _, group := range groups {
 result = append(result, group)
 }

 return result
}

func sortString(s string) string {
 runes := []rune(s)
 sort.Slice(runes, func(i, j int) bool { return runes[i] &lt; runes[j] })
 return string(runes)
}</code></pre>
<p>The <code>groupAnagrams</code> function takes a slice of strings
called <code>words</code> as input and groups them by their anagrams,
returning a slice of slices where each inner slice contains all the
words that are anagrams of each other.</p>
<p>The function first creates an empty map called <code>groups</code>
that will be used to store the groups of anagrams. For each word in the
input slice, the function sorts its characters to get its canonical
form, and adds the word to the group for its canonical form in the
<code>groups</code> map. The sorting is performed by the
<code>sortString</code> function, which converts a string to a slice of
runes, sorts the runes using the <code>sort.Slice</code> function, and
converts the sorted slice back to a string.</p>
<p>Finally, the function converts the <code>groups</code> map to a slice
of slices called <code>result</code> by iterating over the values of the
map and appending each value (i.e., a slice of strings) to
<code>result</code>. The function then returns <code>result</code>,
which contains all the groups of anagrams.</p>
<p>Sure, here’s a possible implementation of a function that takes in a
list of integers and returns the k most frequent integers using a hash
table:</p>
<pre class="golang"><code>func topKFrequent(nums []int, k int) []int {
 count := make(map[int]int)

 // count the frequency of each number
 for _, num := range nums {
 count[num]++
 }

 // build a max heap of size k
 var heap []int
 for num := range count {
 heap = append(heap, num)
 if len(heap) &gt; k {
 heap = removeMin(heap, count)
 }
 }

 // return the k most frequent numbers
 result := make([]int, k)
 for i := 0; i &lt; k; i++ {
 result[i] = heap[i]
 }
 return result
}

func removeMin(heap []int, count map[int]int) []int {
 // find the minimum element in the heap
 minIndex := 0
 for i := 1; i &lt; len(heap); i++ {
 if count[heap[i]] &lt; count[heap[minIndex]] {
 minIndex = i
 }
 }

 // remove the minimum element from the heap
 heap[minIndex] = heap[len(heap)-1]
 heap = heap[:len(heap)-1]

 // fix the heap property by sifting down the root
 i := 0
 for {
 left := 2*i + 1
 right := 2*i + 2
 smallest := i
 if left &lt; len(heap) &amp;&amp; count[heap[left]] &lt; count[heap[smallest]] {
 smallest = left
 }
 if right &lt; len(heap) &amp;&amp; count[heap[right]] &lt; count[heap[smallest]] {
 smallest = right
 }
 if smallest != i {
 heap[i], heap[smallest] = heap[smallest], heap[i]
 i = smallest
 } else {
 break
 }
 }

 return heap
}</code></pre>
<p>The <code>topKFrequent</code> function takes a slice of integers
called <code>nums</code> and an integer <code>k</code> as input, and
returns the k most frequent integers in <code>nums</code> using a hash
table and a max heap.</p>
<p>The function first creates an empty map called <code>count</code>
that will be used to count the frequency of each number in
<code>nums</code>. For each number in <code>nums</code>, the function
increments its count in the <code>count</code> map.</p>
<p>The function then builds a max heap of size <code>k</code> using a
slice called <code>heap</code>. For each number in the
<code>count</code> map, the function adds the number to the
<code>heap</code> slice and removes the minimum element from the
<code>heap</code> slice if the size of the <code>heap</code> slice
exceeds <code>k</code>. The <code>removeMin</code> function is used to
remove the minimum element from the <code>heap</code> slice and fix the
heap property by sifting down the root.</p>
<p>Finally, the function returns a slice called <code>result</code> that
contains the <code>k</code> most frequent numbers in <code>nums</code>.
The function initializes <code>result</code> to a slice of size
<code>k</code>, and then copies the first <code>k</code> elements of the
<code>heap</code> slice to <code>result</code>.</p>
<p>Note that the <code>topKFrequent</code> function assumes that
<code>k</code> is less than or equal to the number of distinct integers
in <code>nums</code>. If <code>k</code> is greater than the number of
distinct integers in <code>nums</code>, the function will return a slice
of size less than <code>k</code>.</p>
<p>Sure, here’s an implementation of a hash table that supports resizing
when the load factor exceeds a certain threshold (in this case,
0.75):</p>
<pre class="golang"><code>type Node struct {
 Key int
 Value int
 Next *Node
}

type HashTable struct {
 data []*Node
 size int
 capacity int
 loadFactor float64
}

func NewHashTable() *HashTable {
 return &amp;HashTable{
 data: make([]*Node, 16),
 size: 0,
 capacity: 16,
 loadFactor: 0.75,
 }
}

func (h \*HashTable) hash(key int) int {
 return key % h.capacity
}

func (h \*HashTable) resize() {
 newCapacity := h.capacity * 2
 newData := make([]*Node, newCapacity)

 for i := 0; i &lt; h.capacity; i++ {
 curr := h.data[i]
 for curr != nil {
 next := curr.Next
 idx := h.hash(curr.Key)
 curr.Next = newData[idx]
 newData[idx] = curr
 curr = next
 }
 }

 h.data = newData
 h.capacity = newCapacity
}

func (h \*HashTable) Insert(key int, value int) {
 if float64(h.size)/float64(h.capacity) &gt;= h.loadFactor {
 h.resize()
 }

 idx := h.hash(key)
 node := &amp;Node{Key: key, Value: value}
 node.Next = h.data[idx]
 h.data[idx] = node
 h.size++
}

func (h \*HashTable) Get(key int) int {
 idx := h.hash(key)
 curr := h.data[idx]
 for curr != nil {
 if curr.Key == key {
 return curr.Value
 }
 curr = curr.Next
 }
 return -1
}

func (h \*HashTable) Delete(key int) {
 idx := h.hash(key)
 curr := h.data[idx]
 var prev *Node

 for curr != nil {
 if curr.Key == key {
 if prev == nil {
 h.data[idx] = curr.Next
 } else {
 prev.Next = curr.Next
 }
 h.size--
 return
 }
 prev = curr
 curr = curr.Next
 }
}</code></pre>
<p>This implementation uses linear probing as the collision resolution
technique, and it resizes the hash table when the load factor exceeds
0.75. The hash table is implemented using an array of linked lists,
where each linked list contains the key-value pairs that hash to the
same index. The <code>Insert</code>, <code>Get</code>, and
<code>Delete</code> methods all use the hash function to determine the
index of the array that corresponds to the given key. If there is a
collision (i.e., two keys hash to the same index), linear probing is
used to find the next available slot in the array. The
<code>Insert</code> method checks the load factor before inserting a new
key-value pair, and resizes the hash table if necessary.</p>
<p>To solve this problem, we can make use of a hash table. The idea is
to consider each string as a circular shift of itself, and then use the
hash value of each circular shift as the key in the hash table. If two
strings are rotations of each other, then they will have the same hash
value for some circular shift.</p>
<p>Here’s the algorithm to solve the problem:</p>
<ol type="1">
<li>Initialize an empty hash table.</li>
<li>For each string in the list:</li>
</ol>
<ol type="a">
<li>Generate all circular shifts of the string.</li>
<li>For each circular shift, compute its hash value.</li>
<li>If the hash value is already in the hash table, add the string to
the group of strings associated with that hash value. Otherwise, create
a new group with the string as its only member, and add it to the hash
table with the hash value as the key.</li>
</ol>
<ol start="3" type="1">
<li>Return the groups of strings that have more than one member.</li>
</ol>
<p>Here’s the code in Golang:</p>
<pre class="golang"><code>func findStringRotations(strings []string) [][]string {
 // Initialize hash table
 table := make(map[string][]string)
 
 // Iterate over strings
 for _, s := range strings {
 // Generate circular shifts of string
 shifts := make([]string, len(s))
 for i := range s {
 shifts[i] = s[i:] + s[:i]
 }
 
 // Add shifts to hash table
 for _, shift := range shifts {
 hash := getHash(shift)
 if _, ok := table[hash]; ok {
 table[hash] = append(table[hash], s)
 } else {
 table[hash] = []string{s}
 }
 }
 }
 
 // Collect groups of strings that are rotations of each other
 groups := make([][]string, 0)
 for _, v := range table {
 if len(v) &gt; 1 {
 groups = append(groups, v)
 }
 }
 
 return groups
}

func getHash(s string) string {
 // Compute hash value of string
 hash := 0
 for _, c := range s {
 hash = (hash*31 + int(c)) % 1000000007
 }
 return strconv.Itoa(hash)
}</code></pre>
<p>This code first initializes an empty hash table. Then, for each
string in the input list, it generates all circular shifts of the string
and computes their hash values. It then adds the string to the group of
strings associated with the hash value in the hash table. Finally, it
collects all groups of strings that have more than one member and
returns them.</p>
<p>Here’s a solution in Golang that takes in a list of words and returns
the words that are palindromes using a hash table:</p>
<pre class="golang"><code>func findPalindrome(words []string) []string {
 result := []string{}
 m := make(map[string]bool)

 for _, word := range words {
 if m[word] == true {
 continue
 }
 if isPalindrome(word) {
 result = append(result, word)
 m[word] = true
 }
 }
 return result
}

func isPalindrome(word string) bool {
 for i, j := 0, len(word)-1; i &lt; j; i, j = i+1, j-1 {
 if word[i] != word[j] {
 return false
 }
 }
 return true
}</code></pre>
<p>The <code>findPalindrome</code> function takes in a list of words and
initializes an empty slice <code>result</code> and an empty hash table
<code>m</code>. It then loops through each word in the list and checks
if it is already in the hash table. If it is, it skips to the next word.
If it is not, it checks if the word is a palindrome using the
<code>isPalindrome</code> function. If it is a palindrome, it adds it to
the <code>result</code> slice and sets the value of the word in the hash
table to <code>true</code>. Finally, it returns the <code>result</code>
slice containing all the palindrome words.</p>
<p>The <code>isPalindrome</code> function takes in a word and loops
through its characters from both ends, checking if they match. If they
do not match, it returns <code>false</code>. If all characters match, it
returns <code>true</code>, indicating that the word is a palindrome.</p>
<h2 id="chapter-13-advanced-topics-1">Chapter 13 Advanced Topics</h2>
<p>Examples 1. Solution for estimating the value of pi using Monte Carlo
method in Go:</p>
<pre class="golang"><code>package main

import (
 &quot;fmt&quot;
 &quot;math/rand&quot;
)

func main() {
 const n = 1000000
 var count int
 rand.Seed(42)

 for i := 0; i &lt; n; i++ {
 x := rand.Float64()
 y := rand.Float64()

 if x*x+y*y &lt;= 1 {
 count++
 }
 }

 pi := 4.0 * float64(count) / float64(n)
 fmt.Printf(&quot;Estimated value of pi: %f\n&quot;, pi)
}</code></pre>
<ol start="2" type="1">
<li>Solution for generating a random password in Go:</li>
</ol>
<pre class="golang"><code>package main

import (
 &quot;fmt&quot;
 &quot;math/rand&quot;
 &quot;time&quot;
)

const charset = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;\*()\_+&quot;

func generatePassword(length int) string {
 rand.Seed(time.Now().UnixNano())

 password := make([]byte, length)
 for i := range password {
 password[i] = charset[rand.Intn(len(charset))]
 }
 return string(password)
}

func main() {
 password := generatePassword(10)
 fmt.Println(password)
}</code></pre>
<ol start="3" type="1">
<li>Solution for randomized quicksort in Go:</li>
</ol>
<pre class="golang"><code>package main

import (
 &quot;fmt&quot;
 &quot;math/rand&quot;
)

func quicksort(arr []int) []int {
 if len(arr) &lt; 2 {
 return arr
 }

 pivotIndex := rand.Intn(len(arr))
 pivot := arr[pivotIndex]

 left, right := 0, len(arr)-1
 arr[pivotIndex], arr[right] = arr[right], arr[pivotIndex]

 for i := range arr {
 if arr[i] &lt; pivot {
 arr[i], arr[left] = arr[left], arr[i]
 left++
 }
 }

 arr[left], arr[right] = arr[right], arr[left]

 quicksort(arr[:left])
 quicksort(arr[left+1:])

 return arr
}

func main() {
 arr := []int{5, 2, 9, 1, 5, 6, 8, 3, 7}
 fmt.Println(quicksort(arr))
}</code></pre>
<ol start="4" type="1">
<li>Solution for shuffling a deck of cards using a random number
generator in Go:</li>
</ol>
<pre class="golang"><code>package main

import (
 &quot;fmt&quot;
 &quot;math/rand&quot;
 &quot;time&quot;
)

type Card struct {
 suit string
 rank string
}

func createDeck() []Card {
 suits := []string{&quot;Hearts&quot;, &quot;Diamonds&quot;, &quot;Clubs&quot;, &quot;Spades&quot;}
 ranks := []string{&quot;Ace&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;, &quot;Jack&quot;, &quot;Queen&quot;, &quot;King&quot;}

 deck := []Card{}

 for _, suit := range suits {
 for _, rank := range ranks {
 card := Card{suit, rank}
 deck = append(deck, card)
 }
 }

 return deck
}

func shuffleDeck(deck []Card) []Card {
 rand.Seed(time.Now().UnixNano())

 for i := range deck {
 j := rand.Intn(i + 1)
 deck[i], deck[j] = deck[j], deck[i]
 }

 return deck
}

func main() {
 deck := createDeck()
 shuffledDeck := shuffleDeck(deck)
 fmt.Println(shuffledDeck)
}</code></pre>
</body>
</html>
